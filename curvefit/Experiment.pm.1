#!/usr/bin/perl -w

# A library of calls handy for use in our experiments.
# Exports several function calls into the caller namespace.


BEGIN {
package Experiment;

use strict;
use warnings;
use Socket;
use Fcntl;
use POSIX;
use Time::HiRes;
use Carp;
use Exporter;
# This includes the import method of Exporter as part of this package
# (actually, includes all of Exporter as part of this), so that it gets
# called when you use this package (and exports the stuff listed in
# @EXPORT and so on).
our @ISA=qw(Exporter);


# GLOBALS #############################


# The list of parameters to record with each run.
our @parameters=();
# Name of parameters file.
our $PARAMETERS='PARAMETERS';


# Each key is the name of a box, and the value, if defined, is the string
# that the box was last programmed with.
our %programs=();
# The most recently programmed boxes:
our @programmed_boxes=();


# When you initialize a run (see init_run()), a directory is made, we chdir
# into it (recording the dir we were in in here), save parameters, etc.
# When we end a run (see end_run()), this is undefined, so I can tell when
# we are in a run or not.
our $basedir=undef;
# Also, the current run number.
our $run_num=-1;


# The port to connect to on boxes.
my $box_port=24;
# The UDP port for the UDP ping, and message to send (as well as the
# expected response).
my $box_udp_port=11235;
my $box_udp_msg="Go to blackout!";
my $box_udp_rsp="Goin' dark.";
# The TCP and UDP protocols:
my $tcp_protocol=getprotobyname('tcp') || croak("Could not get TCP protocol ($!).\n");
my $udp_protocol=getprotobyname('udp') || croak("Could not get UDP protocol ($!).\n");
# A timeout for waiting for requests.
my $sock_timeout=5;


# A socket to connect to the camera server, and the name of the socket to
# use.
my $cam_sock=undef;
my $cam_socket='/tmp/camserver';


# This hash contains connections to imgserver programs, for displaying
# images.  The keys are the names of the windows (also included is a
# default name).  The values are hash refs.  The keys of those refs are:
#   read  => a read-filehandle for communicating with the child.
#   write => a write filehandle for communicating with the child.
#   pid   => the pid (not too necessary).
my %img_conn=();
my $default_img_name="Experiment Picture";
# Name of program:
my $img_prog='imgserver';


# The ping program.
my $ping_prog='/sbin/ping';
# The pwd program.
my $pwd_prog='/bin/pwd';


# INTERNAL ROUTINES ###################


# Attempts to open a socket to a given (host,port) combination (TCP).
# Prints error messages.
# Returns the socket on success, and undef on failure.
sub open_socket($$){
	my($host,$port)=@_;
	my($sock,$iaddr,$paddr,$proto,$timestruct);

	# Some checks.
	if(!$host){carp("open_socket(): bad hostname.\n");return undef;}
	if(!$port){carp("open_socket(): bad port.\n");return undef;}
	if($port=~/\D/){
		if(!($port=getservbyname($port,"tcp"))){
			carp("open_socket(): unable to get port number ($!).\n");
			return undef;
		}
	}

	# Get some important stuff.
	if(!($iaddr=inet_aton($host))){
		carp("open_socket(): unable to create address ($!).\n");
		return undef;
	}
	if(!($paddr=sockaddr_in($port,$iaddr))){
		carp("open_socket(): unable to create socket address ($!).\n");
		return undef;
	}

	# Make the socket and connection.
	if(!socket($sock,,PF_INET,SOCK_STREAM,$tcp_protocol)){
		carp("open_socket(): unable to create socket ($!).\n");
		return undef;
	}
	{
		my($sec,$microsec);
		$sec=POSIX::floor($sock_timeout);$microsec=($sock_timeout-$sec)*1000000;
		$timestruct=pack('LL',$sec,$microsec);
	}
	if(!setsockopt($sock,SOL_SOCKET,SO_SNDTIMEO,$timestruct) ||
	   !setsockopt($sock,SOL_SOCKET,SO_RCVTIMEO,$timestruct)){
		carp("open_socket(): unable to set socket timeouts ($!).\n");
		return undef;
	}
	# The timeouts above don't seem to apply to connect, so do it this way:
	{
		my $flag;
		if(!($flag=fcntl($sock,F_GETFL,0))){
			carp("open_socket(): unable to fetch socket flags ($!).\n");
			return undef;
		}
		if(!fcntl($sock,F_SETFL,$flag | O_NONBLOCK)){
			carp("open_socket(): unable to set socket flags ($!).\n");
			return undef;
		}
		if(!connect($sock,$paddr) && ($! != EINPROGRESS)){
			carp("open_socket(): unable to connect socket ($!).\n");
			return undef;
		} 
		if(!fcntl($sock,F_SETFL,$flag)){
			carp("open_socket(): unable to set socket flags ($!).\n");
			return undef;
		}
	}
	# The connect call was done in non-blocking mode, so now, wait the
	# appropriate amount.
	{
		my $end_time=Time::HiRes::time()+$sock_timeout;
		my($bits,$time);
		while(($time=Time::HiRes::time())<$end_time){
			$bits='';vec($bits,fileno($sock),1)=1;
			select(undef,$bits,undef,$end_time-$time);
			if(vec($bits,fileno($sock),1)){last;}
		}
		if($time>=$end_time){
			carp("open_socket(): timed out waiting for connection.\n");
			return undef;
		}
	}
	# Done.  Make it binary and autoflushing, and then return.
	my $oldFH=select($sock);$|=1;select($oldFH);
	binmode($sock);return $sock;
}


# Basically just a macro to convert an address to a host and port string.
# This is used as a key to the hash of what hosts to ping as well as for
# printing, so it needs to be unique and have everything it needs in it.
# This is used as a hash key, because the actual address structure for a
# response may not be identical to the one for what was sent.
# Returns undef for error, and a string for success.
sub addr($){
	my($paddr)=@_;
	if(!defined($paddr)){return undef;}
	my($port,$iaddr)=sockaddr_in($paddr);
	if(!defined($port) || !defined($iaddr)){return undef;}
	my $host=inet_ntoa($iaddr);if(!defined($host)){return undef;}
	return "$host:$port";
}


# Given a file handle, reads everything it can up until there is no more to
# read -- data is discarded.  Returns true normally, and 0 if the handle
# appears to be closed.
sub dump_handle($){
	my($hand)=@_;
	my($bits,$data);
	for(;;){
		$bits='';vec($bits,fileno($hand),1)=1;
		select($bits,undef,undef,0);
		if(!(vec($bits,fileno($hand),1))){return 1;}
		sysread($hand,$data,65536);
		if(!length($data)){return 0;}
	}
}


# Given a hash ref, this treats each key as a host name, and sends a UDP
# ping to each one.  It then waits for responses, until it has waited for a
# specified time, at which point it returns.  The return value is undef for
# error, and a hash ref for success (the keys of the hash are the hosts
# that responded, and the values are false for bad responses and true for
# valid responses).  Complains in the event of an error.
sub udp_ping($){
	my($ref)=@_;
	my($box,$addr,$sock,%rsp,%ret);
	# Checks:
	if(ref($ref) ne 'HASH'){
		carp("udp_ping(): bad argument.\n");
		return undef;
	}
	# Make socket:
	if(!socket($sock,PF_INET,SOCK_DGRAM,$udp_protocol)){
		carp("udp_ping(): error creating socket ($!).\n");
		return undef;
	}
	binmode($sock);
	# Ping:
	foreach $box (keys(%{$ref})){
		my($size,$s);
		# Make an address:
		$addr=inet_aton($box);if(!defined($addr)){
			carp("udp_ping(): unable to make an address for $box.\n");
			return undef;
		}
		$addr=sockaddr_in($box_udp_port,$addr);if(!defined($addr)){
			carp("udp_ping(): unable to make socket address for $box.\n");
			return undef;
		}
		$rsp{addr($addr)}={'box'=>$box};
		# Send the ping:
		for($size=0;;){
			$s=send($sock,substr($box_udp_msg,$size),0,$addr);
			if(!defined($s)){
				carp("udp_ping(): error sending ping to box $box ($!).\n");
				return undef;
			}
			$size+=$s;if($size>=length($box_udp_msg)){last;}
		}
	}
	# Wait for responses.
	%ret=();
	my($end_time,$time);$end_time=Time::HiRes::time()+$sock_timeout;
	# As long as there are non-responders ...
	while(scalar(keys(%rsp)) && ($time=Time::HiRes::time())<$end_time){
		my($bits,$data,$done);
		$bits='';vec($bits,fileno($sock),1)=1;
		select($bits,undef,undef,$end_time-$time);
		if(vec($bits,fileno($sock),1)){
			# A response!
			# recv() is a little nicer than sysread() for UDP, because you get
			# the address, too.
			$addr=recv($sock,$data,length($box_udp_rsp),0);
			if(!defined($addr)){
				carp("udp_ping(): error reading socket ($!).\n");
				return undef;
			}else{
				$addr=addr($addr);
				# Add the response to the stuff we've gotten, and check to see if
				# it is valid.
				if(defined($rsp{$addr})){
					if(!defined($rsp{$addr}{'rsp'})){$rsp{$addr}{'rsp'}=$data;}
					else{$rsp{$addr}{'rsp'}.=$data;}
					if($rsp{$addr}{'rsp'} eq $box_udp_rsp){
						# Mark a valid response and remove from our wait list.
						$ret{$rsp{$addr}{'box'}}=1;delete($rsp{$addr});
					}elsif(length($rsp{$addr}{'rsp'}) >= length($box_udp_rsp)){
						# This response isn't going to be right -- mark it as wrong,
						# and remove it from our wait list.
						$ret{$rsp{$addr}{'box'}}=0;delete($rsp{$addr});
					}
				}
			}
		# End of if(received response){...}
		}
	# End of loop waiting for reponses.
	}
	# Mark the rest of the bad-responders.
	foreach $addr (keys(%rsp)){
		if(defined($rsp{$addr}{'rsp'})){
			$ret{$rsp{$addr}{'box'}}=0;
		}
	}
	return \%ret;
}


# Given a list of events (described below -- these had better be sorted by
# time), this forms a hash.  The keys are all the digital boxes referenced
# (by name), and the values are hash references, of which the important
# keys are 'data', which contain the string with which the box should be
# programmed.  A more complete description of the hash is in the comments
# preceding the program_boxes() routine (the box_data data type).
# Returns the hash reference if successful, and undef for error.  
# Warns about various likely-to-be-problems.
sub digital_box_data(@){
	my @ev_list=@_;
	my($event,$box,$delay,$bit,$b);
	my %digital_box_data=();
	foreach $event (@ev_list){
		# Have the time in the proper units for this type of box.
		# Although the two boards are 180 degrees out of phase, each gets
		# updated every 4 microseconds (they run off a 10MHz clock, divided
		# down by 10, which in turns runs a flip-flop, and then it alternates
		# between the two boards, for a requency of 10MHz/40 = 250kHz).
		# FIXME -- handle different times for different boards inside the box?
		my $dig_time=POSIX::floor($event->{'time'}/0.004+0.5);
		foreach $box (keys(%{$event->{'digital'}})){
			if(!defined($digital_box_data{$box})){
				$digital_box_data{$box}={
					'type'=>'digital',
					'data'=>'',
					'time'=>$dig_time,
					'state'=>0x00000000,
					'new_hi'=>0x00000000,
					'new_lo'=>0x00000000,
				};
			}
			# If the current time is after the current update for the box, add
			# the data and update the time (but don't add the data for negative
			# time -- that's just setting the initial condition).
			# FIXME -- update only if state has changed?  or not, so you can have
			#   delays longer than max time?
			if($dig_time>$digital_box_data{$box}{'time'}){
				# A delay of 0 means the update will be on the next cycle, so we
				# are off by one (hence the "-1").
				# Also, make sure that, as far as programming goes, time actually
				# starts at 0, not whatever negative event last set the state.
				# We won't be making a real change until $dig_time is past zero,
				# not just at 0.
				if($dig_time>0 && $digital_box_data{$box}{'time'}<0){
					$digital_box_data{$box}{'time'}=0;
				}
				$delay=$dig_time-$digital_box_data{$box}{'time'}-1;
				if($delay>4000000000){
					carp("digital_box_data(): obscenely large delay ($delay) at time ",$event->{'time'},"for box $box.\n");
					return undef;
				}
				$digital_box_data{$box}{'state'}|=( $digital_box_data{$box}{'new_hi'});
				$digital_box_data{$box}{'state'}&=(~$digital_box_data{$box}{'new_lo'});
				# Don't actually write a change until the first time you should
				# change it -- AFTER time 0.
				if($dig_time>0){
					$digital_box_data{$box}{'data'}.=
						pack("VV",($delay,$digital_box_data{$box}{'state'}));
				}
				$digital_box_data{$box}{'new_hi'}=0x00000000;
				$digital_box_data{$box}{'new_lo'}=0x00000000;
				$digital_box_data{$box}{'time'}=$dig_time;
			}
			# Handle the event.
			foreach $bit (@{$event->{'digital'}{$box}{'hi'}}){
				$b=(1<<$bit);
				if($digital_box_data{$box}{'new_lo'} & $b){
					carp("digital_box_data(): attempting to set bit $bit both hi and lo at time ",$event->{'time'}," on box $box.\n");
				}elsif($digital_box_data{$box}{'new_hi'} & $b){
					carp("digital_box_data(): trying multiple times to set bit $bit hi at time ",$event->{'time'}," on box $box.\n");
				}else{$digital_box_data{$box}{'new_hi'} |= $b;}
			}
			foreach $bit (@{$event->{'digital'}{$box}{'lo'}}){
				$b=(1<<$bit);
				if($digital_box_data{$box}{'new_hi'} & $b){
					carp("digital_box_data(): attempting to set bit $bit both hi and lo at time ",$event->{'time'}," on box $box.\n");
				}elsif($digital_box_data{$box}{'new_lo'} & $b){
					carp("digital_box_data(): trying multiple times to set bit $bit lo at time ",$event->{'time'}," on box $box.\n");
				}else{$digital_box_data{$box}{'new_lo'} |= $b;}
			}
		# End of digital box programming loop for a given event.
		}
	# End of event loop.
	}
	# Write whatever else needs to be written, to set the final state, and
	# clean up extra stuff that will not be used again.
	foreach $box (keys(%digital_box_data)){
		if($digital_box_data{$box}{'new_hi'} ||
		   $digital_box_data{$box}{'new_lo'}){
			$digital_box_data{$box}{'state'}|=( $digital_box_data{$box}{'new_hi'});
			$digital_box_data{$box}{'state'}&=(~$digital_box_data{$box}{'new_lo'});
			$digital_box_data{$box}{'data'}.=
				pack("VV",(0,$digital_box_data{$box}{'state'}));
			$digital_box_data{$box}{'new_hi'}=0x00000000;
			$digital_box_data{$box}{'new_lo'}=0x00000000;
		}
		delete($digital_box_data{$box}{'time'});
		delete($digital_box_data{$box}{'state'});
		delete($digital_box_data{$box}{'new_hi'});
		delete($digital_box_data{$box}{'new_lo'});
	}
	return \%digital_box_data;
}


# Given a box_data structure (one particular box), this interprets the data
# that was sent, and responds to any requests.  The second argument is the
# most recently read stuff from the box.  The third argument is the box
# name, for more useful error messages (this prints error messages).
# Returns undef for error, negative if box said it was full, 0 if things
# are still going, and postive if we have finished sending data and the
# connection may be closed.
sub respond_to_box($$$){
	my($box_data,$data,$box)=@_;
	# Append data to req:
	if(!defined($box_data->{'req'})){$box_data->{'req'}=$data;}
	else{$box_data->{'req'}.=$data;}
	# Now, handle based on box type:
	if($box_data->{'type'} eq 'digital'){
		# Only respond to a completed request (ends with '\n').
		if($box_data->{'req'}=~/\n$/){
			my $total=0;
			my $req;
			foreach $req (split(/\n+/,$box_data->{'req'})){
				if(!($req=~/^\d+$/)){
					carp("respond_to_box(): bad request from box $box.\n");
					next;
				}
				# A request of 0 means it is full.
				if($req==0){return -1;}
				$total+=$req;
			}
			if($total>length($box_data->{'data'})){
				$total=length($box_data->{'data'});
			}
			# $total now has the number of bytes we should send, so send it.
			# For writing to a network, writing should be limited by network
			# speed and stuff, so there's no reason not to let this block.
			# Make a quick check that the socket seems open.
			if(!defined(fileno($box_data->{'sock'}))){
				carp("respond_to_box(): socket for box $box does not appear to be open.\n");
				return undef;
			}
			while(my $s=syswrite($box_data->{'sock'},substr($box_data->{'data'},0,$total))){
				if(!defined($s)){
					carp("respond_to_box(): problem sending data to box $box ($!).\n");
					return undef;
				}
				# Move the written portion from data to sent.
				$box_data->{'sent'}.=substr($box_data->{'data'},0,$s);
				$box_data->{'data'}=substr($box_data->{'data'},$s);$total-=$s;
				if($total==0){last;}
			}
			if($total>0){
				# Problem sending the data -- it didn't all get sent.
				carp("respond_to_box(): problem sending data to box $box.\n");
				return undef;
			}
			# We have used this request.
			$box_data->{'req'}='';
			# We are done here -- signal if we are done completely
			if(length($box_data->{'data'})==0){return 1;}
		}
		# We are done for now, but not done sending data.
		return 0;
	}else{
		carp("respond_to_box(): unknown box type ".$box_data->{'type'}." for box $box.\n");
		return undef;
	}
}


# PARAMETER MANIPULATION ##############


# Declare a scalar to be a parameter (and defines it) which will be
# recorded with each run.  Just give an array of names (strings), and this
# will add the package names if not given, so they can be referenced later.
# Note that for this to work, the variable must be declared with "our"
# instead of "my".
sub declare_parameter(@){
	my $pkg=caller();
	foreach my $n (@_){
		if($n=~/::/){push(@parameters,$n);}
		else{push(@parameters,"$pkg\::$n");}
	}
}


# Dump parameters.
sub dump_parameters(){
	my $n;
	foreach my $name (@parameters){
		local $,;
		# Strip package name.
		($n)=($name=~/(?:::)*([^:]*)$/);
		no strict 'refs';
		if(!defined(${$name})){print "$n=undefined\n";}
		else{print "$n=",${$name},"\n";}
	}
}


# ACTION/EVENT MANIPULATION ###########
# An action refers to something you can tell a digital or analog box to do.

# For a digital box, it is a set of bits that get set hi, and another set
# of bits that get set low.

# Analog boxes are not yet implemented.

# An event is a set of actions grouped together (possibly different boxes),
# along with a time of when to do it.

# Creates (or adds to an existing one if you supply one as the last
# argument) a digital action -- that is, a list of bits (array ref) to set
# high and a list of bits (array ref) to set low, for a given named box.
# The arrays are copied in this routine, so modifying the passed arrays
# later won't affect these.
# The first argument is the name of the box.
# The second argument is an array reference of bits to set high (0, 1, 2,
#   etc.).
# The third argument is an array reference of bits to set low.
# The fourth argument, if given, is a digital action to which this should
#   be concatenated.  If not supplied, a new digital action is created.
# The idea is that most actions will only affect one box, but you can build
# up multi-box actions with just a few calls to this, passing the same
# action to each call after the first.
# Returns the reference to the hash (undef for error).
# Will warn you if you have bad arguments.
sub digital_action($$$;$){
	my($box,$hi_ref,$lo_ref,$dig_ref)=@_;
	my($bit);
	# Sanity checks and initialization.
	if(!defined($dig_ref)){$dig_ref={};}
	elsif(ref($dig_ref) ne "Digital_Action"){
		carp("digital_action() can only add to a digital action.\n");
		return undef;
	}
	if(ref($hi_ref) ne "ARRAY" || ref($lo_ref) ne "ARRAY"){
		carp("digital_action() needs array references.\n");return undef;
	}
	if(ref($box) ne ""){
		carp("digital_action() needs to be given a name.\n");return undef;
	}
	if(!defined($dig_ref->{$box})){$dig_ref->{$box}={'hi'=>[],'lo'=>[]};}
	# Add the hi bits, with lots of sanity checks.
	foreach $bit (@{$hi_ref}){
		if($bit!=int($bit)){
			carp("digital_action() needs integer bit values (not $bit).\n");next;
		}
		if($bit<0 || $bit>31){
			carp("digital_action() takes bits from 0 to 31, not $bit.\n");next;
		}
		if(grep(/^$bit$/,@{$dig_ref->{$box}{'hi'}})){
			carp("digital_action(): tried to reset a hi bit hi ($bit).\n");next;
		}
		if(grep(/^$bit$/,@{$dig_ref->{$box}{'lo'}})){
			carp("digital_action(): ignoring setting bit $bit lo (already set lo).\n");
			next;
		}
		push(@{$dig_ref->{$box}{'hi'}},$bit);
	}
	# Add the lo bits, with lots of sanity checks.
	foreach $bit (@{$lo_ref}){
		if($bit!=int($bit)){
			carp("digital_action() needs integer bit values (not $bit).\n");next;
		}
		if($bit<0 || $bit>31){
			carp("digital_action() takes bits from 0 to 31, not $bit.\n");next;
		}
		if(grep(/^$bit$/,@{$dig_ref->{$box}{'lo'}})){
			carp("digital_action(): tried to reset a lo bit lo ($bit).\n");next;
		}
		if(grep(/^$bit$/,@{$dig_ref->{$box}{'hi'}})){
			carp("digital_action(): ignoring setting bit $bit lo (already set hi).\n");
			next;
		}
		push(@{$dig_ref->{$box}{'lo'}},$bit);
	}
	# Bless and return.
	bless($dig_ref,"Digital_Action");
}


# Creates an event.  Give it a time and then a list of actions, and it
# returns the event hash reference (undef for error).  The time is in
# milliseconds.
# If you really want, you can have empty events (just a time).
sub event($;@){
	my $time=shift;
	# Make an event.
	my $event={'time'=>$time,'digital'=>{}};
	bless($event->{'digital'},'Digital_Action');
	# Add the actions to the event.
	foreach my $action (@_){
		if(ref($action) eq "Digital_Action"){
			# Re-use the digital_action() routine for clarity, even if this is a
			# bit slow.  For each box in $action, add it to the event's digital
			# action.
			foreach my $box (keys(%{$action})){
				digital_action($box,$action->{$box}{'hi'},$action->{$box}{'lo'},
				               $event->{'digital'});
			}
		}else{
			carp("event(): ignoring unrecognized action.\n");
		}
	}
	# Bless and return.
	bless($event,"Event");
}


# An explanation is in order of the subroutine below.  It uses a lot of
# complicated hashes, which I'll document here:
# Digital_Action (blessed as "Digital_Action"):
# The keys are names of boxes.  The values are hash references.  The hashes
# they reference contain two keys (referring to bits for that particular
# box):
#   'hi'   => a list reference of the bits to set high for this action.
#   'lo'   => a list reference of the bits to set lo for this action.
#   
# Event:
#   'time'    => the time, in milliseconds past when the run starts, that
#                the actions are to occur.
#   'digital' => a combined Digital_Action of all the Digital_Actions
#                making up this event.
#
# Finally, for programming the various boxes, it is convenient to make one
# more data type, this one internal to the following subroutines and some
# of the things it calls.  It isn't officially named, but I'll call it
# box_data.  The keys are each names of boxes, and the values are hash
# references.  Each internal hash may contain the following keys:
#   'type' => type of box ('digital', etc.)
#   'data' => data to send to the box (not yet sent).
#   'sent' => data already sent to the box.
#   'sock' => a socket for connecting to the box.
#   'req'  => for storing responses from the box until they tally up to a
#             full request.
#   others specific to the type of box.

# Given a list of events, this figures out which boxes need to be
# programmed, computes the program data for them, and, if it is different
# than the last thing this routine programmed them with, reprograms them.
# Attempts to write the stuff it programmed to a filename that's the box
# addresss appended with ".prog".
# By default, all boxes are assumed to start in some sort of "off" states.
# To force starting in some other position, you are allowed to give events
# happening at negative times.  The initial state at time 0, when the boxes
# start, will then be the sum total of these previous events.
# It then sends the UDP ping to every box.
# Returns true if everything was successful (or close enough), and undef if
# there was a bad enough error.
sub program_boxes(@){
	my($box,$event);

	# Sort the events by time, with some sanity checking:
	my @ev_list=();
	foreach $event (@_){
		if(ref($event) ne "Event"){
			carp("program_boxes(): skipping something that does not appear to be an event.\n");
			next;
		}
		push(@ev_list,$event);
	}
	@ev_list=sort { $a->{'time'} <=> $b->{'time'} } @ev_list;

	# Make the programs, sorted by box (do it type-by-type).
	# %box_data is of the box_data type of structure talked about comments
	# above this routine.
	my %box_data=();
	{
		my $digital_box_data=digital_box_data(@ev_list);
		if(!defined($digital_box_data)){
			carp("program_boxes(): error handling digital box data.\n");
			return undef;
		}
		# Concatenate into %box_data, checking for duplicate names.
		foreach $box (keys(%{$digital_box_data})){
			if(defined($box_data{$box})){
				carp("program_boxes(): box $box seems to have multiple types.\n");
				return undef;
			}
			$box_data{$box}=$digital_box_data->{$box};
		}
	}

	# Connect to each box that has not been programmed with the most recent
	# data.
	foreach $box (keys(%box_data)){
		if(defined($programs{$box}) &&
		   $programs{$box} eq $box_data{$box}{'data'}){
			next;
		}
		# Save the programs I intend to write.
		if(!open(LOG,">","$box.prog")){
			carp("program_boxes(): error opening log for box $box.\n");
		}else{
			binmode(LOG);
			if(!print LOG ($box_data{$box}{'data'})){
				carp("program_boxes(): error writing log for box $box.\n");
			}
			if(!close(LOG)){
				carp("program_boxes(): error closing log for box $box.\n");
			}
		}
		# When the connections are opened, that clears the memory of the box,
		# so delete the appropriate value of %programs (we will set it again
		# when we have successfully written stuff -- that will happen unless I
		# encounter an error, in which case I'd rather assume I didn't know
		# what was in the box, which is why I leave the value deleted).
		$box_data{$box}{'sock'}=open_socket($box,$box_port);
		if(!defined($box_data{$box}{'sock'})){
			carp("program_boxes(): error connecting to $box.\n");
			return undef;
		}
		delete($programs{$box});
	}
	# Send data as it is requested.
	for(;;){
		my $data='';
		my $alive;
		# Form a select list and select.  A timeout is bad.  If there are no
		# sockets left, we are done.
		my $vec='';
		$alive=0;foreach $box (keys(%box_data)){
			if(!defined($box_data{$box}{'sock'})){next;}
			vec($vec,fileno($box_data{$box}{'sock'}),1)=1;
			++$alive;
		}
		if(!$alive){last;}
		select($vec,undef,undef,$sock_timeout);
		# Read everything that wants reading and handle requests from boxes
		# (closing sockets when done on either end -- warn if the other end
		# closed first).
		$alive=0;foreach $box (keys(%box_data)){
			# Skip boxes that are done, or not ready to read.
			if(!defined($box_data{$box}{'sock'}) ||
			   !vec($vec,fileno($box_data{$box}{'sock'}),1)){next;}
			++$alive;
			sysread($box_data{$box}{'sock'},$data,65536);
			if(length($data)==0){
				#	This seems to be a sign that the connection was closed.
				carp("program_boxes(): the connection to box $box was unexpectedly closed.\n");
				close($box_data{$box}{'sock'});
				delete($box_data{$box}{'sock'});
			}
			my $ret=respond_to_box($box_data{$box},$data,$box);
			if(!defined($ret)){
				carp("program_boxes(): error responding to box $box.\n");
				foreach $box (keys(%box_data)){
					if(defined($box_data{$box}{'sock'})){
						close($box_data{$box}{'sock'});
						delete($box_data{$box}{'sock'});
					}
				}
				return undef;
			}elsif($ret<0){
				carp("program_boxes(): box $box filled up.\n");
				close($box_data{$box}{'sock'});
				delete($box_data{$box}{'sock'});
			}elsif($ret>0){
				# Successfully done.
				close($box_data{$box}{'sock'});
				delete($box_data{$box}{'sock'});
			}
			# Otherwise, we are still going with this box.
		# End of reading any available data from boxes.
		}
		if(!$alive){
			my $strg="program_boxes(): timed out waiting for:\n";
			foreach $box (keys(%box_data)){
				# Skip boxes that are done, or not ready to read.
				if(!defined($box_data{$box}{'sock'})){next;}
				close($box_data{$box}{'sock'});
				delete($box_data{$box}{'sock'});
				$strg.="$box\n";
			}
			carp($strg);return undef;
		}
	# End of sending data to boxes.
	}

	# Save the programs that were sent.
	foreach $box (keys(%box_data)){
		$programs{$box}=$box_data{$box}->{'sent'};
	}

	# Send the UDP pings.
	{
		my $udp_rsp=udp_ping(\%box_data);
		my $err=undef;
		if(!defined($udp_rsp)){
			carp("program_boxes(): unable to send UDP ping.\n");
			return undef;
		}
		foreach $box (keys(%box_data)){
			if(!defined($udp_rsp->{$box})){
				$err.="program_boxes(): box $box did not respond to UDP ping.\n";
			}elsif(!$udp_rsp->{$box}){
				$err.="program_boxes(): box $box gave a bad response to UDP ping\n";
			}
		}
		if(defined($err)){
			carp($err);return undef;
		}
	}

	# We are finally done.  Store which boxes were programmed, and return.
	@programmed_boxes=keys(%box_data);
	return 1;
}


# Sends one ping to each of the boards that was most recently programmed,
# and waits for a response.  The optional argument overrides the default
# period to wait (in seconds).
# WARNING: This forks and takes over the SIGCHLD signals to catch return
# values of children, so it is not compatible with programs that try to do
# the same.
# Returns true for success, and undef for some error (like a timeout).
sub wait_for_boxes(;$){
	my($wait)=@_;if(!defined($wait)){$wait=$sock_timeout;}
	my(%pid,$pid,%box,$box);
	my $msg='';
	# Ping all the boxes -- need to use actual ping program because that's
	# SUID.
	%pid=();my $timeout=POSIX::ceil($wait);
	# Ignore children dying while I start processes.  Then, I'll set up a
	# reaper routine and run it once to catch everything that may have died
	# in between.
	local $SIG{'CHLD'}='IGNORE';
	foreach $box (@programmed_boxes){
		$pid=fork();if(!defined($pid)){
			carp("wait_for_boards(): unable to fork ($!).\n");
			# No reaper in progress, so hardkill everything we have started so
			# far.
			kill(9,keys(%pid));return undef;
		}
		if($pid==0){
			# Child -- exec:
			open(STDIN,"<","/dev/null");
			open(STDOUT,">","/dev/null");
			open(STDERR,">","/dev/null");
			exec {$ping_prog} ('ping','-c','1','-t',$timeout,$box);
			# In case of an error, quit silently:
			exit(128);
		}
		# Parent -- add it to my list.
		$pid{$pid}=$box;
	}
	# %pid keeps track of running processes.  The key is the pid, and the
	# value is the corresponding box.  When a process returns, put the return
	# value in the %box hash (as a value -- the key is the box name).
	# In case any children died right off, call this once to make sure we
	# catch it.
	$SIG{'CHLD'}=sub{
		my $p;while(($p=waitpid(-1,WNOHANG))>0){
			if(defined($pid{$p})){
				$box{$pid{$p}}=$?;
				delete($pid{$p});
			}
		}
	};
	$SIG{'CHLD'}();
	# Now, they've all been pinged.  Wait a bit, and check for return values.
	# Need to wait a bit longer than timeout so that ping can return.
	# Arbitrarily, I choose twice timeout.
	{
		my $end_time=Time::HiRes::time()+$timeout*2;
		my $time;
		while((($time=Time::HiRes::time())<$end_time) && scalar(keys(%pid))){
			select(undef,undef,undef,$end_time-$time);
		}
	}
	# Kill anything that is left.
	if(keys(%pid)){kill(15,keys(%pid));sleep(1);kill(9,keys(%pid));}
	foreach $box (@programmed_boxes){
		if(!defined($box{$box})){
			# It didn't return -- shouldn't happen -- I just killed it.
			$msg.="  process for $box did not quit.\n";
		}elsif($box{$box}){
			# Returned with an error -- remove it from the list.
			$msg.="  $box did not respond (ping returned $box{$box}).\n";
		}
		# Do nothing for a successful return (0).
	}
	if($msg eq ''){return 1;}
	carp("wait_for_boxes(): errors occurred:\n$msg");return undef;
}


# Connects to my camera server.
# Returns undef for error, true for success.
sub cam_open(){
	if(defined($cam_sock)){
		carp("cam_open(): we seem to be connected already.\n");
		return undef;
	}
	if(!socket($cam_sock,AF_UNIX,SOCK_STREAM,0)){
		carp("cam_open(): unable to create socket ($!).\n");
		$cam_sock=undef;return undef;
	}
	if(!connect($cam_sock,sockaddr_un($cam_socket))){
		carp("cam_open(): unable to connect to socket ($!).\n");
		close($cam_sock);$cam_sock=undef;return undef;
	}
	{my $oldfh=select($cam_sock);binmode($cam_sock);$|=1;select($oldfh);}
	return 1;
}


# Sends a string to my camera server (appends the '\n' for you).
# In the event of an error, returns undef and the camera socket will be
# closed.  Returns true for success.
sub cam_command($){
	my($com)=@_;
	if(!defined($cam_sock)){
		carp("cam_command(): camera socket does not seem to be opened.\n");
		return undef;
	}
	dump_handle($cam_sock);
	if(!defined(syswrite($cam_sock,"$com\n"))){
		carp("cam_command(): error sending to socket.  Closing socket.\n");
		close($cam_sock);$cam_sock=undef;return undef;
	}
	return 1;
}


# Sends the takepic command to the camera -- requires only the filename.
# Prepends the current directory if the name doesn't start with a '/'.
# Returns true for success, negative for error (waits a bit for a response
# from the camera that it is waiting).
sub cam_takepic($){
	my($path)=@_;
	if(!defined($cam_sock)){
		carp("cam_takepic(): camera socket does not seem to be opened.\n");
		return undef;
	}
	dump_handle($cam_sock);
	if(!($path=~/^\//)){
		my $pwd=`$pwd_prog`;chomp($pwd);
		$path="${pwd}/${path}";
	}
	if(!cam_command("takepic $path")){
		carp("cam_takepic(): error sending picture command.\n");
		return undef;
	}
	# Wait for a response, but don't wait too long.
	my $end_time=Time::HiRes::time()+$sock_timeout;
	my($bits,$data,$total);$total='';
	while((my $time=Time::HiRes::time())<$end_time){
		$bits='';vec($bits,fileno($cam_sock),1)=1;
		select($bits,undef,undef,$end_time-$time);
		if(vec($bits,fileno($cam_sock),1)){
			sysread($cam_sock,$data,65536);
			$total.=$data;my(@rsp)=split(/\n+/,$total);
			# Here's the response I wanted:
			if(grep(/^Taking picture/,@rsp)){return 1;}
			# Only keep the last line:
			$total=~s/^.*\n//os;
		}
	}
	carp("cam_takepic(): timed out waiting for picture response.\n");
	return undef;
}


# Waits for the camera server to respond again (may time out).  If you
# always use this sometime before calling another cam_* command after using
# cam_takepic(), you should never get out of sync with the camera server.
# The optional argument overrides the default timeout (in seconds).
sub cam_wait(;$){
	my($wait)=@_;if(!defined($wait)){$wait=$sock_timeout;}
	if(!defined($cam_sock)){
		carp("cam_wait(): camera socket does not seem to be opened.\n");
		return undef;
	}
	dump_handle($cam_sock);
	# Use the hello command for this.
	if(!cam_command("hello")){
		carp("cam_wait(): error sending command.\n");
		return undef;
	}
	# Wait for a response, but don't wait too long.
	my $end_time=Time::HiRes::time()+$wait;
	my($bits,$data,$total);$total='';
	while((my $time=Time::HiRes::time())<$end_time){
		$bits='';vec($bits,fileno($cam_sock),1)=1;
		select($bits,undef,undef,$end_time-$time);
		if(vec($bits,fileno($cam_sock),1)){
			sysread($cam_sock,$data,65536);
			$total.=$data;my(@rsp)=split(/\n+/,$total);
			# Here's the response I wanted:
			if(grep(/^Hello/,@rsp)){return 1;}
			# Only keep the last line:
			$total=~s/^.*\n//os;
		}
	}
	carp("cam_wait(): timed out waiting for picture response.\n");
	return undef;
}


# Disconnects from my camera server.
# Returns true.
sub cam_close(){
	if(defined($cam_sock)){close($cam_sock);}
	$cam_sock=undef;return 1;
}


# Displays an image using the image server.
# The only required argument is the filename to display (if you make it
# undef, this will possibly start a server, and set it up with whatever
# size and position you give).
# The optional argument is a hash that set various options (all have
# defaults or aren't used if not given).  Keys are:
#   false => true or false, depending on whether you want false colors.
#   pos   => 2-element array reference, with x-y position of window.
#   size  => 2-element array reference, with widht-height of window
#            (negative values should match image size).
#   name  => Name of window (so you can have multiple windows).
# This works by forking, reroutine stdin and stdout, and having the image
# server run in the background.  It will die when the communication channel
# closes, so there is no need to reap, kill, or otherwise monitor the
# program.
# Returns true for success (or so it thinks) and undef for an error
# (probably not worth quitting over, though -- just warn).
sub display($;%){
	my($path,%options)=@_;
	# Make an absolute path, if warranted.
	if(defined($path) && !($path=~/^\//)){
		my $pwd=`$pwd_prog`;chomp($pwd);
		$path="${pwd}/${path}";
	}
	# Set defaults.
	if(!defined($options{'false'})){$options{'false'}=1;}
	my $name;
	if(!defined($options{'name'})){$name=$default_img_name;}
	else{$name=$options{'name'};}
	# If the program does not seem to be open, or seems to have died, run a
	# new program.
	if(!defined($img_conn{$name}) || !dump_handle($img_conn{$name}{'read'})){
		my($tmp_read,$tmp_write);
		if(defined($img_conn{$name}{'read'})){close($img_conn{$name}{'read'});}
		if(defined($img_conn{$name}{'write'})){close($img_conn{$name}{'write'});}
		if(!pipe($tmp_read,$img_conn{$name}{'write'})){
			carp("display(): unable to open write pipe ($!).\n");
			return undef;
		}
		if(!pipe($img_conn{$name}{'read'},$tmp_write)){
			carp("display(): unable to open read pipe ($!).\n");
			close($tmp_read);close($img_conn{$name}{'write'});
			return undef;
		}
		my $tmp=select($tmp_read);$|=1;select($tmp_write);$|=1;
		select($img_conn{$name}{'read'});$|=1;
		select($img_conn{$name}{'write'});$|=1;
		select($tmp);
		binmode($tmp_read);binmode($tmp_write);
		binmode($img_conn{$name}{'read'});
		binmode($img_conn{$name}{'write'});
		# Now, fork() and run.
		my $pid=fork();if(!defined($pid)){
			carp("display(): unable to fork ($!).\n");return undef;
		}if(!$pid){
			# Child -- don't bother getting away from the controlling terminal --
			# it's OK to receive the signals here.
			open(STDIN,'<&',$tmp_read);
			open(STDOUT,'>&',$tmp_write);
			# Leave STDERR, for error messages.
			close($tmp_read);close($tmp_write);
			close($img_conn{$name}{'read'});
			close($img_conn{$name}{'write'});
			exec {$img_prog} ('imgserver',$name);
			# In case of an error, quit silently:
			exit(128);
		}
		# Parent.  Don't bother waiting for anything -- if the child dies,
		# there should be a message on STDERR for the user to see, and I don't
		# want to have to worry about output from the program being buffered.
		close($tmp_read);close($tmp_write);
		$img_conn{$name}{'pid'}=$pid;
	}
	# Now, send the commands.
	if(!dump_handle($img_conn{$name}{'read'})){
		carp("display(): unable to read from pipe.\n");
		close($img_conn{$name}{'read'});
		close($img_conn{$name}{'write'});
		delete($img_conn{$name});
		return undef;
	}
	my $command='';
	if(defined($path)){
		if(defined($options{'false'}) && $options{'false'}){
			$command="false $path\n";
		}else{$command="display $path\n";}
	}
	if(ref($options{'pos'}) eq 'ARRAY' && scalar(@{$options{'pos'}})==2){
		$command.="move $options{'pos'}[0] $options{'pos'}[1]\n";
	}
	if(ref($options{'size'}) eq 'ARRAY' && scalar(@{$options{'size'}})==2){
		$command.="resize $options{'size'}[0] $options{'size'}[1]\n";
	}
	# Don't bother selecting on the write -- if the pipe is closed, the write
	# will fail (but do block the SIGPIPE). 
	# Also, don't bother waiting for the response -- let it display on its
	# own while we go on.
	local $SIG{'PIPE'}='IGNORE';
	if(!syswrite($img_conn{$name}{'write'},$command)){
		carp("display(): error sending command to image server ($!).\n");
		close($img_conn{$name}{'read'});
		close($img_conn{$name}{'write'});
		delete($img_conn{$name});
		return undef;
	}
	dump_handle($img_conn{$name}{'read'});
	return 1;
}


# Initializes a run by making a directory just for the run, chdir into it,
# and recording all the parameters into the PARAMETERS file in it.
# Returns true for success, undef for error.
sub init_run(){
	if(defined($basedir)){
		carp("init_run(): already in a run.\n");
		return undef;
	}
	my $run=$run_num+1;
	# Make the dir, and chdir.
	my $name="run.".sprintf('%04u',$run);
	if(!mkdir($name)){
		carp("init_run(): unable to create $name ($!).\n");
		return undef;
	}
	my $dir=`$pwd_prog`;chomp($dir);if(!defined($dir)){
		carp("init_run(): unable to get current directory.\n");
		return undef;
	}
	if(!chdir($name)){
		carp("init_run(): unable to chdir to $name ($!).\n");
		return undef;
	}
	# Record date and parameters.
	if(!open(P,">",$PARAMETERS)){
		carp("init_run(): unable to create parameters file ($!).\n");
		return undef;
	}
	my $date=localtime();
	if(!print P ("# $date\n")){
		carp("init_run(): error writing date to parameters file ($!).\n");
		close(P);return undef;
	}
	foreach my $name (@parameters){
		my $n;
		local $,;
		# Strip package name.
		($n)=($name=~/(?:::)*([^:]*)$/);
		no strict 'refs';
		if(!print P ("$n=",${$name},"\n")){
			carp("init_run(): error writing to parameters file ($!).\n");
			close(P);return undef;
		}
	}
	if(!close(P)){
		carp("init_run(): error closing parameters file ($!).\n");
		return undef;
	}

	# Success.
	$basedir=$dir;$run_num=$run;return 1;
}


# Ends a run by moving out of the run directory.
# Returns true for success, undef for error.
sub end_run(){
	if(!defined($basedir)){
		carp("end_run(): no run currently initialized.\n");
		return undef;
	}
	if(!chdir($basedir)){
		carp("end_run(): unable to chdir ($!).\n");
		return undef;
	}
	$basedir=undef;
	return 1;
}


# EXPORT STUFF ########################


our @EXPORT=qw(&declare_parameter &dump_parameters
               &digital_action &event
               &program_boxes &wait_for_boxes
               &cam_open &cam_command &cam_takepic &cam_wait &cam_close
               &display
               &init_run &end_run);
our @EXPORT_OK=();


}
1;

#ifndef MATRIXR_H_
#define MATRIXR_H_

#include <complex>
#include <vector>
#include "vecr.h"
#include "utility.h"

#undef _LINALG_

enum element {xx=0, yx, zx, xy, yy, zy, xz, yz, zz};

#ifdef _LINALG_
// pulling in C-style code from lapack to use in this c++ program

// Calculate the eigen values & vectors of a system
extern "C" { 
	int dgeev_(char const *jobvl, char const *jobvr, int const *n, double const *a,  int const *lda, double *wr, double *wi, double *vl, int const *ldvl, double *vr, int const *ldvr, double *work, int const *lwork, int *info);
}

// Calculate the inverse of a matrix
extern "C" {
	int	dgetri_ (int const *n, double *A, int const *lda, int const *ipiv, double *work, int *lwork, int *info);
}

// Calculate the L and U factorization of a matrix
extern "C" {
	int dgetrf_ (int const *m, int const *n, double *A, int const *lda, int *ipiv, int *info);
}

#endif

// ***** NOTE ******
// all matrices are to be treated as column-major - see below for more info
class MatR {

private:
	double _elements[9];		// elements will be entered column-major to preserve the fortran style of lapack
	/* i.e. if we were to list the indices of the elements in the matrix they would look like:
	 * 		0	3	6
	 * 		1	4	7
	 * 		2	5	8
	 */
	double _eigenvalsR[3];
	double _eigenvalsI[3];
	double _eigenvecs[9];

	bool _eigenset;

public:
	MatR ()
		{ for (int i=0; i<9; i++) _elements[i] = 0.0; _eigenset = false; }

	MatR (double const * const elements)		// constructor from a pre-built array
		{ for (int i = 0; i < 9; i++) _elements[i] = elements[i]; _eigenset = false; }

	MatR (const MatR& oldMat)			// A copy constructor
		{ for (int i=0; i<9; i++) _elements[i] = oldMat.Elements()[i]; _eigenset = false; }

	~MatR () {};

// Operators
	MatR	operator+ (const MatR& input) const;		// matrix addition
	VecR 	operator* (const VecR& input) const;		// Vector rotation
	MatR 	operator* (const MatR& input) const;		// Matrix rotation
	double	operator[] (int const index) const	// Return the coordinate
		{ return _elements[index]; }
		
	MatR RotateToFrame (VecR const * const frame) const;

	double	Index (int const row, int const col) const	// Return the element
		{ return _elements[col*3+row]; }
		
	void	Set (int const row, int const col, double const val)	// Set the element
		{ _elements[col*3+row] = val; }

	void	Set (double * data)
		{ for (int i=0; i<9; i++) _elements[i] = data[i]; }

	MatR	Transpose () 	const;
#ifdef _LINALG_
	MatR 	Inverse () 	 	const;
	MatR	Diagonalize ();
#endif

// Input & matrix manipulation
	void Zero ()								// Zero all elements of a matrix
		{ for (int i=0; i<9; i++) _elements[i] = 0.0; }

// Output
#ifdef _LINALG_
	vector< complex<double> > 	EigenValues ();
	vector<VecR> 				EigenVectors ();
	void 						CalcEigenSystem ();
	MatR 						Quaternion ();
#endif
	double						Trace ()			const;

	void Print () const;

	double const * Elements () const { return _elements; }

};

#endif

#include "morita.h"

int main (int argc, char *argv) {

	FILE * output = fopen (OUTPUTFILE, "w");
	printf ("outputting to file: %s\n", OUTPUTFILE);
	
	// here is our system for analysis
	AmberSystem sys (PRMTOP, MDCRD, FORCE);
	sys.UseMatrix();

	// This will be our sfg-analysis toybox
	SFGWaterAnalyzer sfg;

	// let's set up a few useful containers that we'll use later on
	vector< complex<double> > beta;		// hyperpolarizability spectrum
	vector< complex<double> > chi;		// hyperpolarizability spectrum

	const int mols = 586;

	bool first = true;
	Water * water;

	const coord axis = y;

	int SFGaxis[3];

	// elements 0 & 1 are the S components, and element 2 is the P
	if (axis == x) {
		SFGaxis[0] = 1;
		SFGaxis[1] = 2;
		SFGaxis[2] = 0;
	}

	if (axis == y) {
		SFGaxis[0] = 0;
		SFGaxis[1] = 2;
		SFGaxis[2] = 1;
	}

	if (axis == z) {
		SFGaxis[0] = 0;
		SFGaxis[1] = 1;
		SFGaxis[2] = 2;
	}


#ifdef TIMESTEPS
	int step = 0;
	#ifdef OUTPUT_FREQ
	printf ("Generating SFG for %d timesteps\n\"*\" = %d steps\n", TIMESTEPS, OUTPUT_FREQ);
	#endif
	for (step=0; step < TIMESTEPS; step++) {
#endif

#ifdef MOLS
	int molcount = 0;
	#ifdef OUTPUT_FREQ
	printf ("Generating SFG for %d molecules\n\"*\" = %d\n", MOLS, OUTPUT_FREQ);
	#endif
	while (molcount < MOLS) {
#endif

		for (int mol = 0; mol < mols; mol++) {

			// we're only looking at waters
			if (sys.Molecules(mol)->Name() != "h2o") continue;

			// first thing we do is grab a water molecule to work with
			water = static_cast<Water *>(sys.Molecules(mol));

			// check that the molecule is interfacial
#ifdef INTERFACE 
			Atom * oxy = water->GetAtom("O");
			double pos = oxy->Position()[axis];
			if (pos > 6.0 && pos < 55.0) continue;
			//if (pos < INTERFACE) continue;
			//if (pos < 15.0) {
			// for molecules below the bottom surface, shift them up to fill out the top surface (so they aren't disconnected)
			//	water->Shift (VecR (0.0, Atom::Size()[axis], 0.0));		
			//	pos = oxy->Position()[axis];
			//}

			/*	Another way of shifting the molecules to meet the other surface
			if (pos > 15 && pos < 35) continue;
			if (pos < 26.0) {
				water->Reflect(y, 26.0);
			}
			*/
#endif

			sfg.Reset();		// reset the calculator for a new molecule
#ifdef MOLS
			molcount++;

	#ifdef OUTPUT_FREQ
			// an output meter
			if (!(molcount % (OUTPUT_FREQ * 10))) {
				printf ("\n%10d/%d)  ", molcount, MOLS);
				rewind (output);
				RUN (chi) {
					fprintf (output, "% 10.5f\t% 10.5f\n", 
						(double(i)*FREQ_STEP+START_FREQ)*FREQFACTOR, abs(chi[i])*abs(chi[i])/MOLS);
				}
				fflush (output);
			}
			if (!(molcount % OUTPUT_FREQ)) { printf ("*"); fflush (stdout); }     
	#endif

			if (molcount == MOLS) break;
#endif

#ifdef SPS
			beta = sfg.BetaRotated (*water, SFGaxis[0],SFGaxis[2],SFGaxis[0]);
#endif

#ifdef SSP
			beta = sfg.BetaRotated (*water, SFGaxis[0],SFGaxis[0],SFGaxis[2]);
#endif

			if (first) {
				chi.clear();
				chi.resize (beta.size(), complex<double> (0.0, 0.0));
				first = false;
			}
		
			RUN (chi) {
				chi[i] += beta[i];
			}

#ifdef SPS
			beta = sfg.BetaRotated (*water, SFGaxis[1],SFGaxis[2],SFGaxis[1]);
#endif

#ifdef SSP
			beta = sfg.BetaRotated (*water, SFGaxis[1],SFGaxis[1],SFGaxis[2]);
#endif

			RUN (chi) {
				chi[i] += beta[i];
			}

		}

#ifdef TIMESTEPS
	#ifdef OUTPUT_FREQ
		// an output meter
		if (!(step % (OUTPUT_FREQ * 10))) {
			printf ("\n%10d/%d)  ", step, TIMESTEPS);
			rewind (output);
			RUN (chi) {
				fprintf (output, "% 10.5f\t% 10.5f\n", 
					(double(i)*FREQ_STEP+START_FREQ)*FREQFACTOR, abs(chi[i])*abs(chi[i])/TIMESTEPS/mols);
			}
			fflush (output);
		}
		if (!(step % OUTPUT_FREQ)) { printf ("*"); fflush (stdout); }     
	#endif
#endif

	sys.LoadNext();
	}

	rewind (output);
	RUN (chi) {
#ifdef TIMESTEPS
		fprintf (output, "% 10.5f\t% 10.5f\n", (double(i)*FREQ_STEP+START_FREQ)*FREQFACTOR, abs(chi[i])*abs(chi[i])/TIMESTEPS/mols);
#endif

#ifdef MOLS
		fprintf (output, "% 10.5f\t% 10.5f\n", (double(i)*FREQ_STEP+START_FREQ)*FREQFACTOR, abs(chi[i])*abs(chi[i])/MOLS);
#endif
	}

	fclose(output);

return 0;
}

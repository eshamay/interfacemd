#ifndef ANGLEDISTRO_H_
#define ANGLEDISTRO_H_

#include <stdio.h>  
#include <stdlib.h>

#include "../utility.h"
#include "../ambersystem.h"

#define PRMTOP  "prmtop"
#define MDCRD   "mdcrd"
#define FORCE   "mdvel"

#define AXIS	1

#define OUTPUT_FILE	"angledistro.dat"

#define	ZMAX	80.0
#define	ZMIN	-5.0
#define	ZRES	0.1

#define AMAX	1.0
#define	AMIN	-1.0
#define ARES	0.02

class AngleDistro {

private:
	AmberSystem _sys;
	int _axis;

	double _zmin, _zmax, _zres;
	int _zbins;

	double _anglemin, _anglemax, _angleres;
	int _anglebins;

	FILE * _output;

	vector< vector<int> > _histo;
	void _ClearHisto ();

	int _timestep;

	void _PrintStatus () const;
	void _PrintOutput () const;
	vector< vector<int> > _WaterStepHistogram ();

public:
	
	AngleDistro ();
	~AngleDistro ();

	vector< vector<int> >& WaterHistogram (int const timesteps);

};

AngleDistro::AngleDistro () : _sys(AmberSystem (PRMTOP, MDCRD, FORCE)){
	
	_zmax = ZMAX;
	_zmin = ZMIN;
	_zres = ZRES;
	
	_anglemax = AMAX;
	_anglemin = AMIN;
	_angleres = ARES;
	
	_zbins = int((_zmax-_zmin)/_zres) + 1;
	_anglebins = int((_anglemax-_anglemin)/_angleres) + 1;

	_axis = AXIS;
	
	_timestep = 0;

	_output = (FILE *)NULL;
	_output = fopen(OUTPUT_FILE, "w");		// the output file
	if (!_output) {
		printf ("couldn't open the output file\n");
		exit(1);
	}

	this->_ClearHisto();

return;
}

AngleDistro::~AngleDistro () {
	
	fclose(_output);

return;
}


// a status output meter
void AngleDistro::_PrintStatus () const {

	if (!(_timestep % 2500)) 
		cout << endl << _timestep << ") ";
	if (!(_timestep % 250))  
		cout << "*";

return;
}

void AngleDistro::_PrintOutput () const {

	rewind (_output);

	for (int i = 0; i < _zbins; i++) {
		for (int j = 0; j < _anglebins; j++) {
			fprintf (_output, "% 10d", _histo[i][j]);
/*
			fprintf (output, "% 10.3f\t% 10.3f\t% 10d\n", 
				(double)i*zres+zmin, 
				(double)j*angleres+anglemin, histo[i][j]);
*/
		}
		fprintf (_output, "\n");
	}

return;
}

vector< vector<int> > AngleDistro::_WaterStepHistogram () {

	vector< vector<int> > stepHisto;
	stepHisto.resize (_zbins, vector<int> ());
	RUN (stepHisto) {
		stepHisto[i].resize (_anglebins, 0);
	}

	VecR X (1.0, 0.0, 0.0);
	VecR Y (0.0, 1.0, 0.0);
	VecR Z (0.0, 0.0, 1.0);

	RUN (_sys.Molecules()) {
			
		if (_sys.Molecules(i)->Name() != "h2o") continue;

		Water * wat = static_cast<Water *>(_sys.Molecules(i));
		Atom * O = wat->GetAtom("O");

		double pos = O->Position()[_axis];
		// system-specific modifier
		if (pos < 15.0) pos += Atom::Size()[_axis];
		int posbin = int ((pos-_zmin)/_zres);

		wat->FindOHBonds();
		double tilt = wat->Bisector() < Y;
		int tiltbin = int ((tilt-_anglemin)/_angleres);

		fflush(stdout);

		stepHisto[posbin][tiltbin]++;
	}

return stepHisto;
}

vector< vector<int> >& AngleDistro::WaterHistogram (int const timesteps) {

	this->_ClearHisto();

	for (_timestep = 0; _timestep < timesteps; _timestep++) {

		vector< vector<int> > stepHisto = this->_WaterStepHistogram ();

		RUN (_histo) {
			RUN2 (_histo[0]) {
				_histo[i][j] += stepHisto[i][j];
			}
		}

		if (!(_timestep % 2500)) 
			this->_PrintOutput ();
		this->_PrintStatus();

		_sys.LoadNext();
	}

return _histo;
}

void AngleDistro::_ClearHisto () {
	
	_histo.clear();
	_histo.resize(_zbins, vector<int> ());

	RUN (_histo) {
		_histo[i].resize (_anglebins, 0);
	}
			
return;
}

#endif

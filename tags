!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
AMBER2ATOMIC	watersfg.h	/^const double AMBER2ATOMIC		=	1.0\/HARTREE2KCALPMOL\/ANG2BOHR;	\/\/ convert amber forces (kcal\/mol\/A) into atomic force units$/;"	v
AMBERMPISYS_H_	ambermpisys.h	2;"	d
AMBERSYSTEM_H_	ambersystem.h	2;"	d
ANALYSISFILES	Makefile	/^ANALYSISFILES	=	analysis.o xyzsystem.o connectmatrix.o dipoleparm.o h2o.o hno3.o matrixr.o molecule.o atom.o vecr.o wannier.o xyzfile.o$/;"	m
ANG2BOHR	watersfg.h	/^const double ANG2BOHR			=	1.889726125;					\/\/ angstroms to bohr radii$/;"	v
ATOM_H_	atom.h	2;"	d
AU2WAVENUMBER	watersfg.h	/^const double AU2WAVENUMBER		=	HZ2WAVENUMBER\/HZ2AU;			\/\/ convert from frequencies in atomic units to cm-1 (note: **not angular frequencies!** For that we need to fix the factor of 2*Pi)$/;"	v
A_HOO	hno3analysis.h	/^const double A_HOO = 35.0;			\/\/ The angle of the H-O...O above which we don't have an H-bond.$/;"	v
AddAtom	molecule.cpp	/^void Molecule::AddAtom (Atom * atom) {$/;"	f	class:Molecule
AddBond	bondgraph.cpp	/^Bond * BondGraph::AddBond (const AtomNode * u, const AtomNode * v, double length) {$/;"	f	class:BondGraph
AddEdge	graph.cpp	/^Edge * Graph::AddEdge (Node * u, Node * v) {$/;"	f	class:Graph
AddEdge	node.cpp	/^void Node::AddEdge (Edge * e) {$/;"	f	class:Node
AddNode	graph.cpp	/^Node * Graph::AddNode () {$/;"	f	class:Graph
AddWannier	molecule.h	/^	void AddWannier (VecR& wannier) { _wanniers.push_back(wannier); } \/\/ adds a wannier center into the molecule$/;"	f	class:Molecule
AdjacencyMatrix	adjacencymatrix.cpp	/^AdjacencyMatrix::AdjacencyMatrix () :$/;"	f	class:AdjacencyMatrix
AdjacencyMatrix	adjacencymatrix.cpp	/^AdjacencyMatrix::AdjacencyMatrix (const Atom_ptr_vec& atoms) :$/;"	f	class:AdjacencyMatrix
AdjacencyMatrix	adjacencymatrix.h	/^class AdjacencyMatrix {$/;"	c
AdjacencyMatrix	connectmatrix.h	/^class AdjacencyMatrix {$/;"	c
Adjacent	graph.cpp	/^Node * Graph::Adjacent (const Node const * u, const Edge const * e) const {$/;"	f	class:Graph
AdjacentNodes	graph.cpp	/^Node_ptr_list Graph::AdjacentNodes (const Node const * u) const {$/;"	f	class:Graph
Alpha	h2o.h	/^	MatR const & Alpha () const { return _alpha; }$/;"	f	class:Water
AlphaDeriv1	watersfg.h	/^	MatR AlphaDeriv1;			\/\/ polarizability deriv matrix for the first OH bond in the frame of the 1st OH bond$/;"	m	class:SFGCalculator
AlphaDeriv2	watersfg.h	/^	MatR AlphaDeriv2;			\/\/ polarizability deriv matrix of the 2nd OH in the frame of the 1st OH (through unitary transformation)$/;"	m	class:SFGCalculator
AmberSystem	ambersystem.cpp	/^AmberSystem::AmberSystem (string prmtop, string mdcrd, string mdvel = "")$/;"	f	class:AmberSystem
AmberSystem	ambersystem.h	/^class AmberSystem {$/;"	c
Angle	h2o.h	/^	double Angle () const { return acos(_oh1 < _oh2) * 180.0\/M_PI; }$/;"	f	class:Water
Atom	atom.cpp	/^Atom::Atom () :$/;"	f	class:Atom
Atom	atom.cpp	/^Atom::Atom (VecR position) :$/;"	f	class:Atom
Atom	atom.cpp	/^Atom::Atom (const Atom& oldAtom) :$/;"	f	class:Atom
Atom	atom.cpp	/^Atom::Atom (std::string name, VecR position) :$/;"	f	class:Atom
Atom	atom.cpp	/^Atom::Atom (std::string name, VecR position, VecR force) :$/;"	f	class:Atom
Atom	atom.h	/^class Atom {$/;"	c
AtomNames	topfile.h	/^	std::vector<std::string>& AtomNames () { return _atomnames; }$/;"	f	class:TOPFile
AtomNode	bondgraph.h	/^class AtomNode : public Node {$/;"	c
AtomNode_it	bondgraph.h	/^typedef std::list<AtomNode *> AtomNode_it;$/;"	t
AtomNode_ptr_list	bondgraph.h	/^typedef std::list<AtomNode *> AtomNode_ptr_list;$/;"	t
Atom_it	atom.h	/^typedef std::vector<Atom>::iterator Atom_it;$/;"	t
Atom_ptr_it	atom.h	/^typedef std::vector<Atom *>::iterator Atom_ptr_it;$/;"	t
Atom_ptr_vec	atom.h	/^typedef std::vector<Atom *> Atom_ptr_vec;$/;"	t
Atom_vec	atom.h	/^typedef std::vector<Atom> Atom_vec;;$/;"	t
Atoms	ambermpisys.h	/^	Atom * Atoms (int index) { return &_atoms[index]; }$/;"	f	class:MPIMolSystem
Atoms	ambersystem.h	/^	Atom * Atoms (int index) 	{ return _atoms[index]; }$/;"	f	class:AmberSystem
Atoms	ambersystem.h	/^	std::vector<Atom *>& Atoms () { return _atoms; }$/;"	f	class:AmberSystem
Atoms	molecule.h	/^	Atom * Atoms (int index) const		{ return _atoms[index]; }$/;"	f	class:Molecule
Atoms	molecule.h	/^	Atom_ptr_vec Atoms () const			{ return _atoms; }			\/\/ returns the molecule's atom list$/;"	f	class:Molecule
Atoms	pdbfile.h	/^	Atom * Atoms (int index) { return _atoms[index]; }$/;"	f	class:PDBFile
Atoms	xyzfile.h	/^	std::vector<Atom *>& Atoms () { return _atoms; }$/;"	f	class:XYZFile
Atoms	xyzsystem.h	/^	Atom * Atoms (int atom) {$/;"	f	class:XYZSystem
BLOCK_HIGH	ambermpisys.h	10;"	d
BLOCK_LOW	ambermpisys.h	9;"	d
BLOCK_OWNER	ambermpisys.h	12;"	d
BLOCK_SIZE	ambermpisys.h	11;"	d
BONDGRAPH_H_	bondgraph.h	2;"	d
BOND_H_	bond.h	2;"	d
BOXFILLER_H_	boxfiller.h	2;"	d
Beta	watersfg.cpp	/^std::vector< std::complex<double> >& SFGCalculator::Beta (Water& water, const int s1, const int s2, const int p) {$/;"	f	class:SFGCalculator
Bin	histogram.h	/^	int Bin (int const value) const {		\/\/ calculates the bin for the given value$/;"	f	class:Histogram
BinSize	histogram.h	/^	double BinSize () { return _binSize; }$/;"	f	class:Histogram
Bisector	h2o.cpp	/^VecR Water::Bisector () {$/;"	f	class:Water
BlockHigh	ambermpisys.h	/^	int BlockHigh (int n) { return BLOCK_HIGH(_id, _p, n); }$/;"	f	class:MPIMolSystem
BlockLow	ambermpisys.h	/^	int BlockLow (int n) { return BLOCK_LOW(_id, _p, n); }$/;"	f	class:MPIMolSystem
BlockSize	ambermpisys.h	/^	int BlockSize (int n) { return BLOCK_SIZE(_id, _p, n); }$/;"	f	class:MPIMolSystem
Bond	bond.cpp	/^Bond::Bond () :$/;"	f	class:Bond
Bond	bond.cpp	/^Bond::Bond (const Bond& oldBond) :$/;"	f	class:Bond
Bond	bond.cpp	/^Bond::Bond (double length, bondtype btype) :$/;"	f	class:Bond
Bond	bond.h	/^class Bond {$/;"	c
BondGraph	bondgraph.cpp	/^BondGraph::BondGraph () {$/;"	f	class:BondGraph
BondGraph	bondgraph.cpp	/^BondGraph::BondGraph (Atom_ptr_vec& atoms) {$/;"	f	class:BondGraph
BondGraph	bondgraph.h	/^class BondGraph : public Graph {$/;"	c
BondTrajectory	wateranalyzer.h	/^vector<double> WaterAnalyzer::BondTrajectory (string atomName1, string atomName2, double bondlengthmax) {$/;"	f	class:WaterAnalyzer
Bond_matrix	adjacencymatrix.h	/^typedef std::vector< Bond_vec > Bond_matrix;$/;"	t
Bond_ptr_matrix	adjacencymatrix.h	/^typedef std::vector< Bond_ptr_vec > Bond_ptr_matrix;$/;"	t
Bond_ptr_vec	adjacencymatrix.h	/^typedef std::vector<Bond *> Bond_ptr_vec;$/;"	t
Bond_ptr_vec	bond.h	/^typedef std::vector<Bond *> Bond_ptr_vec;$/;"	t
Bond_vec	adjacencymatrix.h	/^typedef std::vector<Bond> Bond_vec;$/;"	t
BondedAtoms	adjacencymatrix.cpp	/^Atom_ptr_vec AdjacencyMatrix::BondedAtoms (Atom const * const ap) {$/;"	f	class:AdjacencyMatrix
BondedAtoms	adjacencymatrix.cpp	/^Atom_ptr_vec AdjacencyMatrix::BondedAtoms (Atom const * const ap, bondtype const b) {$/;"	f	class:AdjacencyMatrix
BondedAtoms	adjacencymatrix.cpp	/^Atom_ptr_vec AdjacencyMatrix::BondedAtoms (Atom const * const ap, bondtype const b, const std::string name) {$/;"	f	class:AdjacencyMatrix
Bonds	adjacencymatrix.cpp	/^Bond_ptr_vec AdjacencyMatrix::Bonds (Atom const * const ap) {$/;"	f	class:AdjacencyMatrix
BoxFiller	boxfiller.cpp	/^BoxFiller::BoxFiller (string paramfile, string pdbfile, double spacing) : _pdb(PDBFile(pdbfile)) {$/;"	f	class:BoxFiller
BoxFiller	boxfiller.h	/^class BoxFiller {$/;"	c
BuildMatrix	adjacencymatrix.cpp	/^void AdjacencyMatrix::BuildMatrix () {$/;"	f	class:AdjacencyMatrix
C1	moritasfg2002.h	/^const double C1 =  0.1396,$/;"	v
C2	moritasfg2002.h	/^			 C2 = -0.1196,$/;"	v
C3	moritasfg2002.h	/^			 C3 = -0.0164,$/;"	v
C4	moritasfg2002.h	/^			 C4 = -0.0288,$/;"	v
C5	moritasfg2002.h	/^			 C5 = -0.0516,$/;"	v
C6	moritasfg2002.h	/^			 C6 =  0.0532,$/;"	v
C7	moritasfg2002.h	/^			 C7 = -0.0699,$/;"	v
C8	moritasfg2002.h	/^			 C8 =  0.0169,$/;"	v
C9	moritasfg2002.h	/^			 C9 =  0.1142;$/;"	v
CINCLUDE	Makefile	/^CINCLUDE	= -I$(SRCLIB) -I$(FTENSOR)$/;"	m
CLIBS	Makefile	/^CLIBS		= -L$(MKL) -lmkl_lapack -lmkl -lguide -lpthread$/;"	m
CONNECTMATRIX_H_	adjacencymatrix.h	2;"	d
CONNECTMATRIX_H_	connectmatrix.h	2;"	d
COUPLING_CONST	watersfg.h	/^const double COUPLING_CONST		= 49.5\/AU2WAVENUMBER;				\/\/ Coupling const taken from the energy gap of the sym + antisym stretches (V12 in atomic units)$/;"	v
CPPFLAGS	Makefile	/^CPPFLAGS	= $(CINCLUDE)$/;"	m
CRDFILE_H_	crdfile.h	2;"	d
CRDFile	crdfile.cpp	/^CRDFile::CRDFile (std::string crdpath, int size) :$/;"	f	class:CRDFile
CRDFile	crdfile.h	/^class CRDFile {$/;"	c
CXX	Makefile	/^CXX			= g++ $(CXXFLAGS)$/;"	m
CXXFLAGS	Makefile	/^CXXFLAGS	= -ftemplate-depth-100 -Drestrict= $(CXXOPTIMIZE) $(CINCLUDE)$/;"	m
CXXOPTIMIZE	Makefile	/^CXXOPTIMIZE = -O0 -g3 -finline-functions -finline-limit-1000 -funroll-loops$/;"	m
CalcDipole	molecule.cpp	/^VecR Molecule::CalcDipole () {$/;"	f	class:Molecule
CalcDipole	moritasfg2002.cpp	/^VecR MoritaSFG::CalcDipole (Water * water) {$/;"	f	class:MoritaSFG
CalcEulerAngles	h2o.cpp	/^void Water::CalcEulerAngles (const coord axis) {$/;"	f	class:Water
CalcNO2Dipole	hno3.cpp	/^bool NitricAcid::CalcNO2Dipole () {$/;"	f	class:NitricAcid
CalcPolarizability	moritasfg2002.cpp	/^MatR MoritaSFG::CalcPolarizability (Water * water) {$/;"	f	class:MoritaSFG
CalcTotalPolarizability	moritasfg2002.cpp	/^MatR& MoritaSFG::CalcTotalPolarizability (std::vector<Water *>& wats) {$/;"	f	class:MoritaSFG
CalcTotalPolarization	moritasfg2002.cpp	/^VecR& MoritaSFG::CalcTotalPolarization (std::vector<Water *>& wats) {$/;"	f	class:MoritaSFG
CenterOfMass	molecule.h	/^	VecR CenterOfMass () const		{ return _centerofmass; }$/;"	f	class:Molecule
Charge	atom.h	/^	double Charge () const 	{ return _charge; }$/;"	f	class:Atom
Charges	topfile.h	/^	std::vector<double>& Charges () 	{ return _charges; }$/;"	f	class:TOPFile
Clear	graph.cpp	/^void Graph::Clear () {$/;"	f	class:Graph
ClearBonds	adjacencymatrix.cpp	/^void AdjacencyMatrix::ClearBonds () {$/;"	f	class:AdjacencyMatrix
ClearWanniers	molecule.h	/^	void ClearWanniers () { _wanniers.clear(); }	\/\/ clear out the entire list$/;"	f	class:Molecule
ClosestAtoms	connectmatrix.cpp	/^std::vector<Atom *> ConnectivityMatrix::ClosestAtoms (const int input, const string atomname, const int number) const {$/;"	f	class:ConnectivityMatrix
ComplexDataFile	complexdatafile.cpp	/^ComplexDataFile::ComplexDataFile (const char * pathname) {$/;"	f	class:ComplexDataFile
ComplexDataFile	complexdatafile.h	/^class ComplexDataFile {$/;"	c
ConnectivityMatrix	connectmatrix.cpp	/^ConnectivityMatrix::ConnectivityMatrix (std::vector<Atom *>& atoms) : _atoms(atoms) {$/;"	f	class:ConnectivityMatrix
CoordName	bondgraph.h	/^	string CoordName (const coordination coord) {$/;"	f	class:BondGraph
CoordName	connectmatrix.cpp	/^const string CoordName (coordination coord) {$/;"	f
CoordNameMap	bondgraph.h	/^	coord_map& CoordNameMap () { return _coord_names; }$/;"	f	class:BondGraph
CoordTrajectories	wateranalyzer.h	/^vector< vector<trajectory> > WaterAnalyzer::CoordTrajectories () {$/;"	f	class:WaterAnalyzer
Coords	ambersystem.h	/^	VecR& Coords (int index)	{ return _coords[index]; }$/;"	f	class:AmberSystem
Coords	crdfile.h	/^	const std::vector<VecR>& Coords () const { return _coords; }$/;"	f	class:CRDFile
Coords	wannier.h	/^	const std::vector<VecR>& Coords () const { return _coords; }$/;"	f	class:WannierFile
CouplingConstant	watersfg.cpp	/^double SFGCalculator::CouplingConstant (Water& water) const {$/;"	f	class:SFGCalculator
CovalentBond	adjacencymatrix.cpp	/^bool AdjacencyMatrix::CovalentBond (bondtype const b) const {$/;"	f	class:AdjacencyMatrix
CovalentBonds	connectmatrix.cpp	/^std::vector<Atom *> ConnectivityMatrix::CovalentBonds (const Atom * atom) const {$/;"	f	class:ConnectivityMatrix
Current	ambersystem.h	/^	int 	Current ()		const 	{ return _coords.Current(); }$/;"	f	class:AmberSystem
Current	crdfile.h	/^	int Current () 	const { return _frame; }$/;"	f	class:CRDFile
Current	forcefile.h	/^	int Current () 	{ return _frame; }$/;"	f	class:ForceFile
Current	pdbfile.h	/^	int Current () { return _currentstep; }$/;"	f	class:PDBFile
Current	wannier.h	/^	int Current () 	const { return _frame; }$/;"	f	class:WannierFile
Current	xyzfile.h	/^	int Current () const { return _currentstep; }$/;"	f	class:XYZFile
Current	xyzsystem.h	/^	int Current ()		const { return _atoms.Current(); }$/;"	f	class:XYZSystem
D1	moritasfg2002.h	/^const double D1 = 4.6077,$/;"	v
D2	moritasfg2002.h	/^			 D2 = 4.8894,$/;"	v
D3	moritasfg2002.h	/^			 D3 = 5.5062,$/;"	v
D4	moritasfg2002.h	/^			 D4 = 1.6890,$/;"	v
D5	moritasfg2002.h	/^			 D5 = 1.6102,$/;"	v
D6	moritasfg2002.h	/^			 D6 = 7.3812,$/;"	v
D7	moritasfg2002.h	/^			 D7 = 3.4710;$/;"	v
DCM	h2o.h	/^	MatR DCM;											\/\/ the direction cosine matrix for rotating the molecule to the lab frame$/;"	m	class:Water
DCMToLab	h2o.cpp	/^MatR const & Water::DCMToLab (const coord axis) {$/;"	f	class:Water
DCMToLabMorita	h2o.cpp	/^MatR const & Water::DCMToLabMorita (const coord axis, const int bond) {$/;"	f	class:Water
DCMToLabOrder	h2o.cpp	/^MatR const & Water::DCMToLabOrder () {$/;"	f	class:Water
DEBUG	xyzsystem.h	15;"	d
DIPOLEPARM_H_	dipoleparm.h	2;"	d
DR	rdf.h	7;"	d
DataPoint	complexdatafile.cpp	/^std::complex<double> ComplexDataFile::DataPoint (const double data) {$/;"	f	class:ComplexDataFile
Dbl_mtr	moritasfg2002.h	/^typedef std::vector< std::vector< double > > Dbl_mtr;$/;"	t
Degree	node.h	/^	int Degree () const { return edges.size(); }$/;"	f	class:Node
Determinant	matrixr.cpp	/^double MatR::Determinant () const {$/;"	f	class:MatR
Dims	ambersystem.h	/^	VecR	Dims () 		const 	{ return _coords.Dims(); }		\/\/ returns the system size.$/;"	f	class:AmberSystem
Dims	crdfile.h	/^	const VecR& Dims () const { return _dims; }$/;"	f	class:CRDFile
Dipole	dipoleparm.h	/^	VecR Dipole (double r1, double r2, double theta) {$/;"	f	class:WaterDipoleParms
Dipole	h2o.h	/^	VecR const & Dipole () const { return _dipole; }			\/\/ calculates the dipole (from a parameterized source)$/;"	f	class:Water
Dipole	molecule.h	/^	VecR Dipole () const { return _dipole; }		\/\/ return the dipole of the molecule$/;"	f	class:Molecule
DipoleCorrelation	wateranalyzer.h	/^trajectory WaterAnalyzer::DipoleCorrelation () {$/;"	f	class:WaterAnalyzer
DipoleFieldTensor	dipolefieldtensor.cpp	/^DipoleFieldTensor::DipoleFieldTensor (double const * const r) {$/;"	f	class:DipoleFieldTensor
DipoleFieldTensor	dipolefieldtensor.h	/^class DipoleFieldTensor {$/;"	c
DipolePotential	watersfg.cpp	/^double SFGCalculator::DipolePotential (const VecR& muA, const VecR& muB, const VecR& R) {$/;"	f	class:SFGCalculator
Distance	adjacencymatrix.h	/^	double Distance (Atom const * const a1, Atom const * const a2) {$/;"	f	class:AdjacencyMatrix
Distance	connectmatrix.cpp	/^double ConnectivityMatrix::Distance (const Atom * atom1, const Atom * atom2) const {$/;"	f	class:ConnectivityMatrix
Distance_matrix	adjacencymatrix.h	/^typedef std::vector< std::vector< VecR > > Distance_matrix;$/;"	t
Double_matrix	matrixr.h	/^typedef std::vector< Double_vector >	Double_matrix;$/;"	t
Double_vector	vecr.h	/^typedef std::vector<double>	Double_vector;$/;"	t
EDGE_H_	edge.h	2;"	d
END_FREQ	watersfg.h	/^const double END_FREQ			= 3800.0\/AU2WAVENUMBER;$/;"	v
Edge	edge.cpp	/^Edge::Edge () {$/;"	f	class:Edge
Edge	edge.cpp	/^Edge::Edge (Node * i, Node * j) {$/;"	f	class:Edge
Edge	edge.h	/^class Edge {$/;"	c
Edge	graph.cpp	/^Edge * Graph::Edge (Node * u, Node * v) {$/;"	f	class:Graph
Edge_it	edge.h	/^typedef std::list<Edge *>::iterator Edge_it;$/;"	t
Edge_ptr_list	edge.h	/^typedef std::list<Edge *> Edge_ptr_list;$/;"	t
Element	dipolefieldtensor.h	/^	double const Element (int const row, int const col) const { return _tensor[col*3+row]; }$/;"	f	class:DipoleFieldTensor
EulerAngles	h2o.h	/^	double EulerAngles[3];				\/\/ euler angles as defined in "The Raman Effect" Appendix A5 (theta, phi, chi)$/;"	m	class:Water
EulerAngles	molecule.h	/^	double * EulerAngles () 		{ return _eulerangles; }$/;"	f	class:Molecule
EulerMatrix	h2o.h	/^	MatR EulerMatrix;					\/\/ The euler rotation matrix$/;"	m	class:Water
FORCEFILE_H_	forcefile.h	2;"	d
FREQ_STEP	watersfg.h	/^const double FREQ_STEP			= 1.0\/AU2WAVENUMBER;		\/\/ step size when calculating the spectra$/;"	v
FTENSOR	Makefile	/^FTENSOR		= $(SRCLIB)\/include\/FTensor-1.1pre25$/;"	m
File	topfile.h	/^	FILE * File () const { return _topfile; }$/;"	f	class:TOPFile
FindBond	bondgraph.cpp	/^Bond * BondGraph::FindBond (const Atom * x, const Atom * y) const {$/;"	f	class:BondGraph
FindEulerAngles	backup.h	/^void Water::FindEulerAngles () {$/;"	f	class:Water
FindFlag	topfile.cpp	/^void TOPFile::FindFlag (std::string flag) {$/;"	f	class:TOPFile
FindInterfaces	ambermpisys.h	/^vector<double> MPIMolSystem::FindInterfaces (string atomName, string residue) {$/;"	f	class:MPIMolSystem
FindInterfaces	interfaces.h	/^vector<double> FindInterfaces (string atomName, string residue) {$/;"	f
FindInterfacialWaters	watersystem.cpp	/^void WaterSystem::FindInterfacialWaters () {$/;"	f	class:WaterSystem
FindWaterCoordination	connectmatrix.cpp	/^coordination ConnectivityMatrix::FindWaterCoordination (const Water& water) const {$/;"	f	class:ConnectivityMatrix
FindWaters	watersystem.cpp	/^void WaterSystem::FindWaters () {$/;"	f	class:WaterSystem
First	pdbfile.h	/^	int First () { return _initstep; }$/;"	f	class:PDBFile
Force	atom.h	/^	const VecR& Force () const		{ return _force; }$/;"	f	class:Atom
Force	atom.h	/^	void Force (const VecR& force) { _force = force; }$/;"	f	class:Atom
Force	atom.h	/^	void Force (coord const axis, double const value) { _force.Set (axis, value); }$/;"	f	class:Atom
Force	atom.h	/^	void Force (double X, double Y, double Z) { _force.Set(X, Y, Z); }$/;"	f	class:Atom
ForceFile	forcefile.cpp	/^ForceFile::ForceFile (std::string forcepath, int size) :$/;"	f	class:ForceFile
ForceFile	forcefile.h	/^class ForceFile {$/;"	c
Forces	ambersystem.h	/^	VecR& Forces (int index)	{ return _forces[index]; }$/;"	f	class:AmberSystem
Forces	forcefile.h	/^	const std::vector<VecR>& Forces () const { return _forces; }$/;"	f	class:ForceFile
FreqShift	watersfg.cpp	/^void SFGCalculator::FreqShift (Water& water) {$/;"	f	class:SFGCalculator
GAMMA	watersfg.h	/^const double GAMMA				= 2.0\/AU2WAVENUMBER;				\/\/ the "damping parameter" first shown in Eq. 3 scaled down to some value (between 2 and 22 cm-1 as Dave put it)$/;"	v
GAMMA_SQ	watersfg.h	/^const double GAMMA_SQ			= GAMMA*GAMMA;				\/\/ ...squared$/;"	v
GRAPH_H_	graph.h	2;"	d
GetAtom	molecule.cpp	/^Atom * Molecule::GetAtom (const string atomname) const {$/;"	f	class:Molecule
GetBond	adjacencymatrix.cpp	/^Bond * AdjacencyMatrix::GetBond (Atom const * const a1, Atom const * const a2) {$/;"	f	class:AdjacencyMatrix
GetH	hno3.h	/^	Atom * GetH () const { return _h; }$/;"	f	class:NitricAcid
GetOH	hno3.h	/^	Atom * GetOH () const { return _oh; }$/;"	f	class:NitricAcid
Graph	graph.cpp	/^Graph::Graph () {$/;"	f	class:Graph
Graph	graph.h	/^class Graph {$/;"	c
H	bond.h	/^	H=10, OH=11, OOH=12, OOOH=13, OOOOH=14,			\/\/ 1 H$/;"	e	enum:__anon3
H	bondgraph.h	/^	H=10, OH=11, OOH=12, OOOH=13, OOOOH=14,			\/\/ 1 H$/;"	e	enum:__anon1
H	connectmatrix.h	/^	H=10, OH=11, OOH=12, OOOH=13, OOOOH=14,			\/\/ 1 H$/;"	e	enum:__anon5
H2O_H_	h2o.h	2;"	d
H3O_H_	h3o.h	2;"	d
HARTREE2KCALPMOL	watersfg.h	/^const double HARTREE2KCALPMOL	=	627.509;						\/\/ from hartree to kcal\/mol$/;"	v
HBONDANGLE	bond.h	/^const double HBONDANGLE	= 30.0*M_PI\/180.0;		\/\/ bonding angle has to be less than this value to be considered an H-bond$/;"	v
HBONDANGLE	bondgraph.h	/^const double HBONDANGLE	= 0.866025;		\/\/ cos(theta) has to be less than this value to be considered an H-bond$/;"	v
HBONDANGLE	connectmatrix.h	/^const double HBONDANGLE	= 0.866025;		\/\/ cos(theta) has to be less than this value to be considered an H-bond$/;"	v
HBONDLENGTH	bond.h	/^const double HBONDLENGTH  = 2.5;				\/\/ used to be 2.46$/;"	v
HBONDLENGTH	bondgraph.h	/^const double HBONDLENGTH  = 2.46;$/;"	v
HBONDLENGTH	connectmatrix.h	/^const double HBONDLENGTH  = 2.46;$/;"	v
HBonds	adjacencymatrix.cpp	/^Bond_ptr_vec AdjacencyMatrix::HBonds (Atom const * const ap) {$/;"	f	class:AdjacencyMatrix
HH	bond.h	/^	HH=20, OHH=21, OOHH=22, OOOHH=23, OOOOHH=24,		\/\/ 2 Hs$/;"	e	enum:__anon3
HH	bondgraph.h	/^	HH=20, OHH=21, OOHH=22, OOOHH=23, OOOOHH=24,		\/\/ 2 Hs$/;"	e	enum:__anon1
HH	connectmatrix.h	/^	HH=20, OHH=21, OOHH=22, OOOHH=23, OOOOHH=24,		\/\/ 2 Hs$/;"	e	enum:__anon5
HHH	bond.h	/^	HHH=30, OHHH=31, OOHHH=32, OOOHHH=33, OOOOHHH=34,	\/\/ 3 Hs$/;"	e	enum:__anon3
HHH	bondgraph.h	/^	HHH=30, OHHH=31, OOHHH=32, OOOHHH=33, OOOOHHH=34,	\/\/ 3 Hs$/;"	e	enum:__anon1
HHH	connectmatrix.h	/^	HHH=30, OHHH=31, OOHHH=32, OOOHHH=33, OOOOHHH=34,	\/\/ 3 Hs$/;"	e	enum:__anon5
HHHH	bond.h	/^	HHHH=40, OHHHH=41, OOHHHH=42, OOOHHHH=43, OOOOHHHH=44$/;"	e	enum:__anon3
HHHH	bondgraph.h	/^	HHHH=40, OHHHH=41, OOHHHH=42, OOOHHHH=43, OOOOHHHH=44$/;"	e	enum:__anon1
HHHH	connectmatrix.h	/^	HHHH=40, OHHHH=41, OOHHHH=42, OOOHHHH=43, OOOOHHHH=44$/;"	e	enum:__anon5
HISTOGRAM_H_	histogram.h	2;"	d
HNO3ANALYSIS_H_	hno3analysis.h	2;"	d
HNO3_H_	hno3.h	2;"	d
HZ2AU	watersfg.h	/^const double HZ2AU			=	2.418884324306202e-17;			\/\/ convert Hz to atomic units of frequency$/;"	v
HZ2WAVENUMBER	watersfg.h	/^const double HZ2WAVENUMBER	=	3.335641e-11;				\/\/ convert from Hz to wavenumbers (cm-1)  (this is 1\/c)$/;"	v
Histogram	histogram.cpp	/^Histogram::Histogram (double const min, double const max, double binsize) {$/;"	f	class:Histogram
Histogram	histogram.cpp	/^Histogram::Histogram (double const min, double const max, int numbins) {$/;"	f	class:Histogram
Histogram	histogram.h	/^class Histogram {$/;"	c
Hydronium	h3o.cpp	/^Hydronium::Hydronium () : Molecule()$/;"	f	class:Hydronium
Hydronium	h3o.h	/^class Hydronium: public Molecule {$/;"	c
Hydroxide	oh.cpp	/^Hydroxide::Hydroxide () : Molecule()$/;"	f	class:Hydroxide
Hydroxide	oh.h	/^class Hydroxide: public Molecule {$/;"	c
ID	adjacencymatrix.cpp	/^int AdjacencyMatrix::ID (Atom const * const ap) const {$/;"	f	class:AdjacencyMatrix
ID	ambermpisys.h	/^	int ID () const 			{ return _id; }$/;"	f	class:MPIMolSystem
ID	atom.h	/^	int ID () const 		{ return _ID; }$/;"	f	class:Atom
ID	atom.h	/^	void ID (int id) { _ID = id; }$/;"	f	class:Atom
Index	matrixr.cpp	/^double MatR::Index (coord const row, coord const col) const {	\/\/ Return the element$/;"	f	class:MatR
Index	matrixr.cpp	/^double MatR::Index (int const row, int const col) const {	\/\/ Return the element$/;"	f	class:MatR
Inverse	matrixr.cpp	/^MatR MatR::Inverse () const {$/;"	f	class:MatR
Last	pdbfile.h	/^	int Last () { return _laststep; }$/;"	f	class:PDBFile
LoadFirst	ambersystem.cpp	/^void AmberSystem::LoadFirst () {$/;"	f	class:AmberSystem
LoadFirst	crdfile.cpp	/^void CRDFile::LoadFirst() {$/;"	f	class:CRDFile
LoadFirst	forcefile.cpp	/^void ForceFile::LoadFirst() {$/;"	f	class:ForceFile
LoadFirst	pdbfile.cpp	/^void PDBFile::LoadFirst() {$/;"	f	class:PDBFile
LoadFirst	wannier.cpp	/^void WannierFile::LoadFirst() {$/;"	f	class:WannierFile
LoadFirst	xyzfile.cpp	/^void XYZFile::LoadFirst() {$/;"	f	class:XYZFile
LoadFirst	xyzsystem.cpp	/^void XYZSystem::LoadFirst () {$/;"	f	class:XYZSystem
LoadLast	pdbfile.cpp	/^void PDBFile::LoadLast () {$/;"	f	class:PDBFile
LoadNext	ambermpisys.h	/^void MPIMolSystem::LoadNext () {$/;"	f	class:MPIMolSystem
LoadNext	ambersystem.cpp	/^void AmberSystem::LoadNext () {$/;"	f	class:AmberSystem
LoadNext	crdfile.cpp	/^void CRDFile::LoadNext () {$/;"	f	class:CRDFile
LoadNext	forcefile.cpp	/^void ForceFile::LoadNext () {$/;"	f	class:ForceFile
LoadNext	pdbfile.cpp	/^void PDBFile::LoadNext () {$/;"	f	class:PDBFile
LoadNext	wannier.cpp	/^void WannierFile::LoadNext () {$/;"	f	class:WannierFile
LoadNext	xyzfile.cpp	/^void XYZFile::LoadNext () {$/;"	f	class:XYZFile
LoadNext	xyzsystem.cpp	/^void XYZSystem::LoadNext () {$/;"	f	class:XYZSystem
LoadSection	topfile.cpp	/^void TOPFile::LoadSection(std::string flag) {$/;"	f	class:TOPFile
Loaded	forcefile.h	/^	bool Loaded ()	{ return _loaded; }$/;"	f	class:ForceFile
Loaded	wannier.h	/^	bool Loaded ()	const { return _loaded; }	\/\/ find out if the file is loaded\/exists$/;"	f	class:WannierFile
M	watersfg.h	/^const double M		=	(MOXY*MHYD)\/(MOXY+MHYD);	\/\/ reduced mass of the OH bond\/oscillator$/;"	v
MATRIXR_H_	matrixr.h	2;"	d
MHYD	watersfg.h	/^const double MHYD	=	(MPROT*1.0+1.0);		\/\/ and mass of a hydrogen$/;"	v
MIN_TRAJ_SIZE	wateranalyzer.h	411;"	d
MOLECULE_H_	molecule.h	2;"	d
MOL_IT	molecule.h	/^typedef std::vector<Molecule>::iterator MOL_IT;$/;"	t
MORITASFG2002_H_	moritasfg2002.h	2;"	d
MOXY	watersfg.h	/^const double MOXY	=	(MPROT*8.0+8.0);		\/\/ mass of an oxygen atom in atomic units$/;"	v
MPICXX	Makefile	/^MPICXX		= mpiCC -g -I$(MPI)\/include$/;"	m
MPILIBS	Makefile	/^MPILIBS		= $(MPI)\/lib\/libmpi.so $(MPI)\/lib\/libmpi_cxx.so$/;"	m
MPIMolSystem	ambermpisys.h	/^MPIMolSystem::MPIMolSystem (int *argc, char ***argv, string prmtop, string mdcrd, string mdvel) {$/;"	f	class:MPIMolSystem
MPIMolSystem	ambermpisys.h	/^class MPIMolSystem {$/;"	c
MPROT	watersfg.h	/^const double MPROT	=	1836.153;				\/\/ in atomic units, this is the mass of a proton. Mass of electron = 1.0$/;"	v
MU_DERIV_LENGTH	watersfg.h	/^const double MU_DERIV_LENGTH = MU_DERIV_MAGNITUDE * OH_COM_LENGTH;		\/\/ length of the differential dipole moment element used in calculating the dipole-dipole interaction energy (in atomic units)$/;"	v
MU_DERIV_MAGNITUDE	watersfg.h	/^const double MU_DERIV_MAGNITUDE = sqrt(-0.058*-0.058 + 0.157*0.157);$/;"	v
Magnitude	dipoleparm.h	/^	double Magnitude (double r1, double r2, double theta) { return _Data(r1, r2, theta)[3]; }$/;"	f	class:WaterDipoleParms
Magnitude	vecr.cpp	/^double VecR::Magnitude () const {$/;"	f	class:VecR
Mass	atom.h	/^	double Mass () const 	{ return _mass; }$/;"	f	class:Atom
Mass	molecule.h	/^	double Mass () const 			{ return _mass; }					\/\/ Returns the molecular mass$/;"	f	class:Molecule
Masses	topfile.h	/^	std::vector<double>& Masses () 	{ return _masses; }$/;"	f	class:TOPFile
Master	ambermpisys.h	/^	bool Master () const 		{ return _master; }$/;"	f	class:MPIMolSystem
MatR	matrixr.h	/^	MatR () : _eigenset(false), _matrix(Double_matrix(3, Double_vector(3, 0.0))) { }$/;"	f	class:MatR
MatR	matrixr.h	/^	MatR (const Double_matrix& elements) : _eigenset(false), _matrix(elements) { }$/;"	f	class:MatR
MatR	matrixr.h	/^	MatR (const MatR& oldMat) : _matrix(oldMat._matrix), _eigenset(false) {$/;"	f	class:MatR
MatR	matrixr.h	/^	MatR (double * const elements) : _eigenset(false), _matrix(Double_matrix(3, Double_vector(3, 0.0))) {$/;"	f	class:MatR
MatR	matrixr.h	/^class MatR {$/;"	c
Matrix	matrixr.h	/^	Double_matrix& Matrix() { return _matrix; }$/;"	f	class:MatR
MatrixInverse	moritasfg2002.cpp	/^void MoritaSFG::MatrixInverse (double *G, int n) {$/;"	f	class:MoritaSFG
Max	histogram.h	/^	double Max () { return _max; }$/;"	f	class:Histogram
Merge	molecule.cpp	/^Molecule * Molecule::Merge (Molecule * mol) {$/;"	f	class:Molecule
Min	histogram.h	/^	double Min () { return _min; }$/;"	f	class:Histogram
MinDistance	atom.cpp	/^double Atom::MinDistance (Atom const * const input) const {$/;"	f	class:Atom
MinDistance	atom.cpp	/^double Atom::MinDistance (const Atom& input) const {$/;"	f	class:Atom
MinDistance	molecule.cpp	/^double Molecule::MinDistance (Molecule& mol) {$/;"	f	class:Molecule
MinDistance	vecr.cpp	/^double VecR::MinDistance (const VecR& input, const VecR& size) const {$/;"	f	class:VecR
MinVector	vecr.cpp	/^VecR VecR::MinVector (const VecR& input, const VecR& size) const {$/;"	f	class:VecR
MolID	atom.h	/^	int MolID () const		{ return _molid; }$/;"	f	class:Atom
MolID	atom.h	/^	void MolID (const int mol) { _molid = mol; }	\/\/ sets the ID of the molecule containing this atom$/;"	f	class:Atom
MolID	molecule.h	/^	int MolID () const				{ return _ID; }$/;"	f	class:Molecule
MolID	molecule.h	/^	void MolID (int ID) { _ID = ID; }$/;"	f	class:Molecule
MolNames	topfile.h	/^	std::vector<std::string>& MolNames () { return _molnames; }$/;"	f	class:TOPFile
MolPointers	topfile.h	/^	std::vector<int>& MolPointers () { return _molpointers; }$/;"	f	class:TOPFile
MolSizes	topfile.h	/^	std::vector<int>& MolSizes ()	{ return _molsizes; }$/;"	f	class:TOPFile
Mol_ptr_vec	molecule.h	/^typedef std::vector<Molecule *> Mol_ptr_vec;$/;"	t
Mol_vec	molecule.h	/^typedef std::vector<Molecule> Mol_vec;$/;"	t
MolecularPlaneVector	hno3.cpp	/^VecR NitricAcid::MolecularPlaneVector () {$/;"	f	class:NitricAcid
Molecule	molecule.cpp	/^Molecule::Molecule () :$/;"	f	class:Molecule
Molecule	molecule.cpp	/^Molecule::Molecule (const Molecule& oldMol) :$/;"	f	class:Molecule
Molecule	molecule.h	/^class Molecule {$/;"	c
MoleculeDensity	density.cpp	/^vector<int> MoleculeDensity ( AmberSystem& sys, double const start, double const end, double const binsize, const coord axis, string atomname) {$/;"	f
Molecules	ambermpisys.h	/^	Molecule * Molecules (int index) { return &_mols[index]; }$/;"	f	class:MPIMolSystem
Molecules	ambersystem.h	/^	Molecule * Molecules (int index) { return _mols[index]; }$/;"	f	class:AmberSystem
Molecules	ambersystem.h	/^	std::vector<Molecule *>& Molecules () { return _mols; }$/;"	f	class:AmberSystem
Molecules	pdbfile.h	/^	vector<Molecule *>& Molecules () { return _molecules; }$/;"	f	class:PDBFile
Molecules	xyzsystem.h	/^	Molecule * Molecules (int mol) { return _mols[mol]; }$/;"	f	class:XYZSystem
Molecules	xyzsystem.h	/^	vector<Molecule *>& Molecules () { return _mols; }$/;"	f	class:XYZSystem
MoritaSFG	moritasfg2002.h	/^	MoritaSFG () : _T_set(false) { ; }$/;"	f	class:MoritaSFG
MoritaSFG	moritasfg2002.h	/^class MoritaSFG {$/;"	c
MuDeriv1	watersfg.h	/^	VecR MuDeriv1;				\/\/ dipole derivative vector from the paper$/;"	m	class:SFGCalculator
MuDeriv2	watersfg.h	/^	VecR MuDeriv2;				\/\/ dipole derivative of the 2nd OH bond in the frame of the first$/;"	m	class:SFGCalculator
NHBONDLENGTH	bond.h	/^const double NHBONDLENGTH = 1.3;		\/\/ uhmm... check this?$/;"	v
NHBONDLENGTH	bondgraph.h	/^const double NHBONDLENGTH = 1.3;		\/\/ uhmm... check this?$/;"	v
NHBONDLENGTH	connectmatrix.h	/^const double NHBONDLENGTH = 1.3;		\/\/ uhmm... check this?$/;"	v
NO1	hno3.h	/^	VecR const * NO1 () { return &_no1; }$/;"	f	class:Nitrate
NO2	hno3.h	/^	VecR const * NO2 () { return &_no2; }$/;"	f	class:Nitrate
NO2Bisector	hno3.cpp	/^VecR NitricAcid::NO2Bisector () {$/;"	f	class:NitricAcid
NO2Dipole	hno3.h	/^	VecR NO2Dipole () const { return _no2dipole; }$/;"	f	class:NitricAcid
NO2Wanniers	hno3.h	/^	const std::vector<VecR>& NO2Wanniers () const { return _no2wanniers; }$/;"	f	class:NitricAcid
NO3	hno3.h	/^	VecR const * NO3 () { return &_no3; }$/;"	f	class:Nitrate
NO3Rotation	wateranalyzer.h	/^trajectory WaterAnalyzer::NO3Rotation () {$/;"	f	class:WaterAnalyzer
NOBONDLENGTH	bond.h	/^const double NOBONDLENGTH = 2.0;$/;"	v
NOBONDLENGTH	bondgraph.h	/^const double NOBONDLENGTH = 2.0;$/;"	v
NOBONDLENGTH	connectmatrix.h	/^const double NOBONDLENGTH = 2.0;$/;"	v
NO_BOND	wateranalyzer.h	9;"	d
NUM_STEP	watersfg.h	/^const double NUM_STEP			= (END_FREQ-START_FREQ)\/FREQ_STEP;$/;"	v
Name	atom.h	/^	std::string Name () const 	{ return (_name); }$/;"	f	class:Atom
Name	atom.h	/^	void Name (const std::string name) { _name = name; }$/;"	f	class:Atom
Name	molecule.h	/^	string Name () const			{ return _name; }$/;"	f	class:Molecule
Name	molecule.h	/^	void Name (string name) { _name = name; }	\/\/ set the molecule's name$/;"	f	class:Molecule
Nitrate	hno3.cpp	/^Nitrate::Nitrate () {$/;"	f	class:Nitrate
Nitrate	hno3.h	/^class Nitrate: public Molecule {$/;"	c
NitricAcid	hno3.cpp	/^NitricAcid::NitricAcid () {$/;"	f	class:NitricAcid
NitricAcid	hno3.h	/^class NitricAcid: public Molecule {$/;"	c
Node	node.cpp	/^Node::Node () {$/;"	f	class:Node
Node	node.h	/^class Node {$/;"	c
Node_it	node.h	/^typedef std::list<Node *>::iterator Node_it;$/;"	t
Node_ptr_list	node.h	/^typedef std::list<Node *> Node_ptr_list;$/;"	t
Normal	h2o.h	/^	VecR Normal () const { return _y; }$/;"	f	class:Water
NumAtoms	ambermpisys.h	/^	int NumAtoms () { return _numAtoms; }$/;"	f	class:MPIMolSystem
NumAtoms	ambersystem.h	/^	int	 	NumAtoms ()		const 	{ return _atoms.size(); }		\/\/ return the number of atoms.$/;"	f	class:AmberSystem
NumAtoms	topfile.h	/^	int NumAtoms () const { return _numAtoms; }$/;"	f	class:TOPFile
NumBins	histogram.h	/^	double NumBins () { return _numBins; }$/;"	f	class:Histogram
NumBonds	adjacencymatrix.h	/^	int NumBonds (Atom const * const ap) {$/;"	f	class:AdjacencyMatrix
NumBonds	bondgraph.h	/^	int NumBonds (const Atom * atom, const bondtype bond) const {$/;"	f	class:BondGraph
NumEdges	graph.h	/^	int NumEdges () const { return Edge::num_edges; }$/;"	f	class:Graph
NumHBonds	adjacencymatrix.cpp	/^int AdjacencyMatrix::NumHBonds (Water const * const wat) {$/;"	f	class:AdjacencyMatrix
NumHBonds	adjacencymatrix.h	/^	int NumHBonds (Atom const * const ap) {$/;"	f	class:AdjacencyMatrix
NumMols	ambermpisys.h	/^	int NumMols () { return _numMols; }$/;"	f	class:MPIMolSystem
NumMols	ambersystem.h	/^	int		NumMols ()		const 	{ return _mols.size(); }		\/\/ returns the number of residues$/;"	f	class:AmberSystem
NumMols	topfile.h	/^	int NumMols () const { return _numMols; }$/;"	f	class:TOPFile
NumNodes	graph.h	/^	int NumNodes () const { return Node::num_nodes; }$/;"	f	class:Graph
NumSteps	xyzfile.h	/^	int NumSteps () const { return _numSteps; }$/;"	f	class:XYZFile
NumSteps	xyzsystem.h	/^	int NumSteps () const { return _atoms.NumSteps(); }		\/\/ number of timesteps in the xyzfile$/;"	f	class:XYZSystem
NumberDensity	density.cpp	/^vector<int> NumberDensity (AmberSystem& sys, double const start, double const end, double const binsize, coord const axis) {$/;"	f
O	bond.h	/^	UNBOUND=0, O=1, OO=2, OOO=3, OOOO=4, 			\/\/ no H$/;"	e	enum:__anon3
O	bondgraph.h	/^	UNBOUND=0, O=1, OO=2, OOO=3, OOOO=4, 			\/\/ no H$/;"	e	enum:__anon1
O	connectmatrix.h	/^	UNBOUND=0, O=1, OO=2, OOO=3, OOOO=4, 			\/\/ no H$/;"	e	enum:__anon5
OH	bond.h	/^	H=10, OH=11, OOH=12, OOOH=13, OOOOH=14,			\/\/ 1 H$/;"	e	enum:__anon3
OH	bondgraph.h	/^	H=10, OH=11, OOH=12, OOOH=13, OOOOH=14,			\/\/ 1 H$/;"	e	enum:__anon1
OH	connectmatrix.h	/^	H=10, OH=11, OOH=12, OOOH=13, OOOOH=14,			\/\/ 1 H$/;"	e	enum:__anon5
OH	hno3.h	/^	VecR& OH () { return _voh; }$/;"	f	class:NitricAcid
OH	oh.h	/^	VecR const * OH () const { return &_oh; }$/;"	f	class:Hydroxide
OH1	h2o.h	/^	VecR const * OH1 () const { return &_oh1; }$/;"	f	class:Water
OH1	h3o.h	/^	VecR const * OH1 () const { return &_oh1; }$/;"	f	class:Hydronium
OH2	h2o.h	/^	VecR const * OH2 () const { return &_oh2; }$/;"	f	class:Water
OH2	h3o.h	/^	VecR const * OH2 () const { return &_oh2; }$/;"	f	class:Hydronium
OH3	h3o.h	/^	VecR const * OH3 () const { return &_oh3; }$/;"	f	class:Hydronium
OHBONDLENGTH	bond.h	/^const double OHBONDLENGTH = 1.3;				\/\/ used to be 1.1$/;"	v
OHBONDLENGTH	bondgraph.h	/^const double OHBONDLENGTH = 1.0;$/;"	v
OHBONDLENGTH	connectmatrix.h	/^const double OHBONDLENGTH = 1.0;$/;"	v
OHH	bond.h	/^	HH=20, OHH=21, OOHH=22, OOOHH=23, OOOOHH=24,		\/\/ 2 Hs$/;"	e	enum:__anon3
OHH	bondgraph.h	/^	HH=20, OHH=21, OOHH=22, OOOHH=23, OOOOHH=24,		\/\/ 2 Hs$/;"	e	enum:__anon1
OHH	connectmatrix.h	/^	HH=20, OHH=21, OOHH=22, OOOHH=23, OOOOHH=24,		\/\/ 2 Hs$/;"	e	enum:__anon5
OHHH	bond.h	/^	HHH=30, OHHH=31, OOHHH=32, OOOHHH=33, OOOOHHH=34,	\/\/ 3 Hs$/;"	e	enum:__anon3
OHHH	bondgraph.h	/^	HHH=30, OHHH=31, OOHHH=32, OOOHHH=33, OOOOHHH=34,	\/\/ 3 Hs$/;"	e	enum:__anon1
OHHH	connectmatrix.h	/^	HHH=30, OHHH=31, OOHHH=32, OOOHHH=33, OOOOHHH=34,	\/\/ 3 Hs$/;"	e	enum:__anon5
OHHHH	bond.h	/^	HHHH=40, OHHHH=41, OOHHHH=42, OOOHHHH=43, OOOOHHHH=44$/;"	e	enum:__anon3
OHHHH	bondgraph.h	/^	HHHH=40, OHHHH=41, OOHHHH=42, OOOHHHH=43, OOOOHHHH=44$/;"	e	enum:__anon1
OHHHH	connectmatrix.h	/^	HHHH=40, OHHHH=41, OOHHHH=42, OOOHHHH=43, OOOOHHHH=44$/;"	e	enum:__anon5
OH_COM_LENGTH	watersfg.h	/^const double OH_COM_LENGTH = MHYD*OH_LENGTH\/(MHYD+MOXY);	\/\/ distance to the center of mass of the OH bond from the oxygen (atomic units of length)$/;"	v
OH_H_	oh.h	2;"	d
OH_LENGTH	watersfg.h	/^const double OH_LENGTH = 1.000*ANG2BOHR;	\/\/ in atomic units$/;"	v
OO	bond.h	/^	UNBOUND=0, O=1, OO=2, OOO=3, OOOO=4, 			\/\/ no H$/;"	e	enum:__anon3
OO	bondgraph.h	/^	UNBOUND=0, O=1, OO=2, OOO=3, OOOO=4, 			\/\/ no H$/;"	e	enum:__anon1
OO	connectmatrix.h	/^	UNBOUND=0, O=1, OO=2, OOO=3, OOOO=4, 			\/\/ no H$/;"	e	enum:__anon5
OOH	bond.h	/^	H=10, OH=11, OOH=12, OOOH=13, OOOOH=14,			\/\/ 1 H$/;"	e	enum:__anon3
OOH	bondgraph.h	/^	H=10, OH=11, OOH=12, OOOH=13, OOOOH=14,			\/\/ 1 H$/;"	e	enum:__anon1
OOH	connectmatrix.h	/^	H=10, OH=11, OOH=12, OOOH=13, OOOOH=14,			\/\/ 1 H$/;"	e	enum:__anon5
OOHH	bond.h	/^	HH=20, OHH=21, OOHH=22, OOOHH=23, OOOOHH=24,		\/\/ 2 Hs$/;"	e	enum:__anon3
OOHH	bondgraph.h	/^	HH=20, OHH=21, OOHH=22, OOOHH=23, OOOOHH=24,		\/\/ 2 Hs$/;"	e	enum:__anon1
OOHH	connectmatrix.h	/^	HH=20, OHH=21, OOHH=22, OOOHH=23, OOOOHH=24,		\/\/ 2 Hs$/;"	e	enum:__anon5
OOHHH	bond.h	/^	HHH=30, OHHH=31, OOHHH=32, OOOHHH=33, OOOOHHH=34,	\/\/ 3 Hs$/;"	e	enum:__anon3
OOHHH	bondgraph.h	/^	HHH=30, OHHH=31, OOHHH=32, OOOHHH=33, OOOOHHH=34,	\/\/ 3 Hs$/;"	e	enum:__anon1
OOHHH	connectmatrix.h	/^	HHH=30, OHHH=31, OOHHH=32, OOOHHH=33, OOOOHHH=34,	\/\/ 3 Hs$/;"	e	enum:__anon5
OOHHHH	bond.h	/^	HHHH=40, OHHHH=41, OOHHHH=42, OOOHHHH=43, OOOOHHHH=44$/;"	e	enum:__anon3
OOHHHH	bondgraph.h	/^	HHHH=40, OHHHH=41, OOHHHH=42, OOOHHHH=43, OOOOHHHH=44$/;"	e	enum:__anon1
OOHHHH	connectmatrix.h	/^	HHHH=40, OHHHH=41, OOHHHH=42, OOOHHHH=43, OOOOHHHH=44$/;"	e	enum:__anon5
OOO	bond.h	/^	UNBOUND=0, O=1, OO=2, OOO=3, OOOO=4, 			\/\/ no H$/;"	e	enum:__anon3
OOO	bondgraph.h	/^	UNBOUND=0, O=1, OO=2, OOO=3, OOOO=4, 			\/\/ no H$/;"	e	enum:__anon1
OOO	connectmatrix.h	/^	UNBOUND=0, O=1, OO=2, OOO=3, OOOO=4, 			\/\/ no H$/;"	e	enum:__anon5
OOOH	bond.h	/^	H=10, OH=11, OOH=12, OOOH=13, OOOOH=14,			\/\/ 1 H$/;"	e	enum:__anon3
OOOH	bondgraph.h	/^	H=10, OH=11, OOH=12, OOOH=13, OOOOH=14,			\/\/ 1 H$/;"	e	enum:__anon1
OOOH	connectmatrix.h	/^	H=10, OH=11, OOH=12, OOOH=13, OOOOH=14,			\/\/ 1 H$/;"	e	enum:__anon5
OOOHH	bond.h	/^	HH=20, OHH=21, OOHH=22, OOOHH=23, OOOOHH=24,		\/\/ 2 Hs$/;"	e	enum:__anon3
OOOHH	bondgraph.h	/^	HH=20, OHH=21, OOHH=22, OOOHH=23, OOOOHH=24,		\/\/ 2 Hs$/;"	e	enum:__anon1
OOOHH	connectmatrix.h	/^	HH=20, OHH=21, OOHH=22, OOOHH=23, OOOOHH=24,		\/\/ 2 Hs$/;"	e	enum:__anon5
OOOHHH	bond.h	/^	HHH=30, OHHH=31, OOHHH=32, OOOHHH=33, OOOOHHH=34,	\/\/ 3 Hs$/;"	e	enum:__anon3
OOOHHH	bondgraph.h	/^	HHH=30, OHHH=31, OOHHH=32, OOOHHH=33, OOOOHHH=34,	\/\/ 3 Hs$/;"	e	enum:__anon1
OOOHHH	connectmatrix.h	/^	HHH=30, OHHH=31, OOHHH=32, OOOHHH=33, OOOOHHH=34,	\/\/ 3 Hs$/;"	e	enum:__anon5
OOOHHHH	bond.h	/^	HHHH=40, OHHHH=41, OOHHHH=42, OOOHHHH=43, OOOOHHHH=44$/;"	e	enum:__anon3
OOOHHHH	bondgraph.h	/^	HHHH=40, OHHHH=41, OOHHHH=42, OOOHHHH=43, OOOOHHHH=44$/;"	e	enum:__anon1
OOOHHHH	connectmatrix.h	/^	HHHH=40, OHHHH=41, OOHHHH=42, OOOHHHH=43, OOOOHHHH=44$/;"	e	enum:__anon5
OOOO	bond.h	/^	UNBOUND=0, O=1, OO=2, OOO=3, OOOO=4, 			\/\/ no H$/;"	e	enum:__anon3
OOOO	bondgraph.h	/^	UNBOUND=0, O=1, OO=2, OOO=3, OOOO=4, 			\/\/ no H$/;"	e	enum:__anon1
OOOO	connectmatrix.h	/^	UNBOUND=0, O=1, OO=2, OOO=3, OOOO=4, 			\/\/ no H$/;"	e	enum:__anon5
OOOOH	bond.h	/^	H=10, OH=11, OOH=12, OOOH=13, OOOOH=14,			\/\/ 1 H$/;"	e	enum:__anon3
OOOOH	bondgraph.h	/^	H=10, OH=11, OOH=12, OOOH=13, OOOOH=14,			\/\/ 1 H$/;"	e	enum:__anon1
OOOOH	connectmatrix.h	/^	H=10, OH=11, OOH=12, OOOH=13, OOOOH=14,			\/\/ 1 H$/;"	e	enum:__anon5
OOOOHH	bond.h	/^	HH=20, OHH=21, OOHH=22, OOOHH=23, OOOOHH=24,		\/\/ 2 Hs$/;"	e	enum:__anon3
OOOOHH	bondgraph.h	/^	HH=20, OHH=21, OOHH=22, OOOHH=23, OOOOHH=24,		\/\/ 2 Hs$/;"	e	enum:__anon1
OOOOHH	connectmatrix.h	/^	HH=20, OHH=21, OOHH=22, OOOHH=23, OOOOHH=24,		\/\/ 2 Hs$/;"	e	enum:__anon5
OOOOHHH	bond.h	/^	HHH=30, OHHH=31, OOHHH=32, OOOHHH=33, OOOOHHH=34,	\/\/ 3 Hs$/;"	e	enum:__anon3
OOOOHHH	bondgraph.h	/^	HHH=30, OHHH=31, OOHHH=32, OOOHHH=33, OOOOHHH=34,	\/\/ 3 Hs$/;"	e	enum:__anon1
OOOOHHH	connectmatrix.h	/^	HHH=30, OHHH=31, OOHHH=32, OOOHHH=33, OOOOHHH=34,	\/\/ 3 Hs$/;"	e	enum:__anon5
OOOOHHHH	bond.h	/^	HHHH=40, OHHHH=41, OOHHHH=42, OOOHHHH=43, OOOOHHHH=44$/;"	e	enum:__anon3
OOOOHHHH	bondgraph.h	/^	HHHH=40, OHHHH=41, OOHHHH=42, OOOHHHH=43, OOOOHHHH=44$/;"	e	enum:__anon1
OOOOHHHH	connectmatrix.h	/^	HHHH=40, OHHHH=41, OOHHHH=42, OOOHHHH=43, OOOOHHHH=44$/;"	e	enum:__anon5
OpenFile	watersystem.cpp	/^void WaterSystem::OpenFile () {$/;"	f	class:WaterSystem
OutputHeader	watersystem.cpp	/^void WaterSystem::OutputHeader(const WaterSystemParams& params) const {$/;"	f	class:WaterSystem
OutputStatus	watersystem.cpp	/^void WaterSystem::OutputStatus () const {$/;"	f	class:WaterSystem
PARAMS	boxfiller.h	10;"	d
PDBFILE	boxfiller.h	11;"	d
PDBFILE_H_	pdbfile.h	2;"	d
PDBFile	pdbfile.cpp	/^PDBFile::PDBFile () {$/;"	f	class:PDBFile
PDBFile	pdbfile.cpp	/^PDBFile::PDBFile (string path) {$/;"	f	class:PDBFile
PDBFile	pdbfile.h	/^class PDBFile {$/;"	c
PMOL_IT	molecule.h	/^typedef std::vector<Molecule *>::iterator PMOL_IT;$/;"	t
PREFACTOR	watersfg.h	/^const double PREFACTOR	=	sqrt(k0\/M)*(l\/(2.0*k0*k0));		\/\/ the prefactor to multiply the bond force for freq shift (in atomic units) (eq 10c)$/;"	v
PRINTV	utility.h	20;"	d
PRINTV2	utility.h	23;"	d
ParentMolecule	atom.h	/^	Molecule * ParentMolecule () const { return _pmolecule; }$/;"	f	class:Atom
ParentMolecule	atom.h	/^	void ParentMolecule (Molecule * mol) { _pmolecule = mol; }	\/\/ sets a pointer to the molecule that contains the atom$/;"	f	class:Atom
PolarizabilityAndDipoleDerivs	watersfg.cpp	/^void SFGCalculator::PolarizabilityAndDipoleDerivs (Water& water, const int s1, const int s2, const int p) {$/;"	f	class:SFGCalculator
Position	atom.h	/^	const VecR& Position () const	{ return _position; }$/;"	f	class:Atom
Position	atom.h	/^	void Position (const VecR& position) { _position = position; }$/;"	f	class:Atom
Position	atom.h	/^	void Position (coord const axis, double const value) { _position.Set (axis, value); }$/;"	f	class:Atom
Position	atom.h	/^	void Position (double X, double Y, double Z) { _position.Set(X, Y, Z); }$/;"	f	class:Atom
Print	atom.cpp	/^void Atom::Print () const {$/;"	f	class:Atom
Print	histogram.cpp	/^void Histogram::Print () {$/;"	f	class:Histogram
Print	matrixr.cpp	/^void MatR::Print () const {$/;"	f	class:MatR
Print	molecule.cpp	/^void Molecule::Print () const {$/;"	f	class:Molecule
Print	vecr.cpp	/^void VecR::Print () const {$/;"	f	class:VecR
PrintCRDFile	ambersystem.cpp	/^void AmberSystem::PrintCRDFile (string filepath) {$/;"	f	class:AmberSystem
PrintNO2	hno3.cpp	/^void NitricAcid::PrintNO2 () const {$/;"	f	class:NitricAcid
Procs	ambermpisys.h	/^	int Procs () const 			{ return _p; }$/;"	f	class:MPIMolSystem
Q_H_eq	moritasfg2002.h	/^const double Q_H_eq		= 0.3285;		\/\/ charge units (atomic units?)$/;"	v
Q_O_eq	moritasfg2002.h	/^const double Q_O_eq		= -0.6570;$/;"	v
RANDOM	boxfiller.h	13;"	d
RDF	rdf.h	/^vector<double> RDF (string atomName1, string atomName2, AmberSystem& sys) {$/;"	f
RDF	wateranalyzer.h	/^vector<double> WaterAnalyzer::RDF (string atomName1, string atomName2) {$/;"	f	class:WaterAnalyzer
RUN	utility.h	8;"	d
RUN2	utility.h	15;"	d
R_OH	hno3analysis.h	/^const double R_OH = 2.45;			\/\/ This is the max value of an H-bond length (from rdf data)$/;"	v
R_OH_H3O_mean	hno3analysis.h	/^const double R_OH_H3O_mean = 1.029;	  \/\/ same but for hydronium$/;"	v
R_OH_HNO3_mean	hno3analysis.h	/^const double R_OH_HNO3_mean = 1.016;  \/\/ avg OH distance on the NO3 according to Hynes... should be recalculate for each simulation.$/;"	v
R_OO	hno3analysis.h	/^const double R_OO = 3.5;			\/\/ These values are the maximums for defining H-bonds between the acceptor water and hno3.$/;"	v
R_eq	moritasfg2002.h	/^const double R_eq 		= 0.9575;		\/\/ in angstroms$/;"	v
Reflect	molecule.cpp	/^void Molecule::Reflect (coord const axis, double const plane) {$/;"	f	class:Molecule
RemoveAtom	molecule.cpp	/^void Molecule::RemoveAtom (const Atom * atom) {$/;"	f	class:Molecule
RemoveEdge	graph.cpp	/^void Graph::RemoveEdge (Edge * e) {$/;"	f	class:Graph
RemoveEdge	node.cpp	/^void Node::RemoveEdge (Edge * e) {$/;"	f	class:Node
RemoveEdges	node.cpp	/^void Node::RemoveEdges () {$/;"	f	class:Node
RemoveNode	graph.cpp	/^void Graph::RemoveNode (Node * u) {$/;"	f	class:Graph
Rename	molecule.cpp	/^void Molecule::Rename (const string name) {$/;"	f	class:Molecule
Reset	watersfg.h	/^	void Reset () { _set = false; }$/;"	f	class:SFGCalculator
Residue	atom.h	/^	std::string Residue () const { return _residue; }$/;"	f	class:Atom
Residue	atom.h	/^	void Residue (std::string residue) { _residue = residue; }$/;"	f	class:Atom
Rotate	molecule.cpp	/^void Molecule::Rotate (VecR origin, VecR axis, double angle) {$/;"	f	class:Molecule
RotateMatrix	molecule.cpp	/^void Molecule::RotateMatrix (double rotation[][3], double matrix[][3]) const {$/;"	f	class:Molecule
RotateToLab	molecule.cpp	/^void Molecule::RotateToLab (double matrix[][3]) const {$/;"	f	class:Molecule
RotateToLab	molecule.cpp	/^void Molecule::RotateToLab (double vector[3]) const {$/;"	f	class:Molecule
RotateToMol	molecule.cpp	/^void Molecule::RotateToMol (double matrix[][3]) const {$/;"	f	class:Molecule
RotateToMol	molecule.cpp	/^void Molecule::RotateToMol (double vector[3]) const {$/;"	f	class:Molecule
RotateVector	molecule.cpp	/^void Molecule::RotateVector (double rotation[][3], double vector[3]) const {$/;"	f	class:Molecule
SFGCalculator	watersfg.cpp	/^SFGCalculator::SFGCalculator (AdjacencyMatrix * matrix) : _matrix(matrix) {$/;"	f	class:SFGCalculator
SFGCalculator	watersfg.h	/^class SFGCalculator {$/;"	c
SPACING	boxfiller.h	12;"	d
SRCLIB	Makefile	/^SRCLIB	 	= $(HOME)\/work\/src$/;"	m
START_FREQ	watersfg.h	/^const double START_FREQ			= 2800.0\/AU2WAVENUMBER;$/;"	v
Seek	pdbfile.cpp	/^void PDBFile::Seek (int step) {$/;"	f	class:PDBFile
Seek	xyzfile.cpp	/^void XYZFile::Seek (int step) {$/;"	f	class:XYZFile
Seek	xyzsystem.cpp	/^void XYZSystem::Seek (int step) {$/;"	f	class:XYZSystem
Set	matrixr.cpp	/^void MatR::Set (coord const row, coord const col, double const val) {	\/\/ Set the element$/;"	f	class:MatR
Set	matrixr.cpp	/^void MatR::Set (double * const data) {$/;"	f	class:MatR
Set	matrixr.cpp	/^void MatR::Set (int const row, int const col, double const val) {	\/\/ Set the element$/;"	f	class:MatR
Set	matrixr.h	/^	void	Set (const MatR& input)$/;"	f	class:MatR
Set	molecule.h	/^	bool Set () { _set = true; return (_set); }$/;"	f	class:Molecule
Set	vecr.h	/^	void Set (const coord axis, const double val) { _coords[axis] = val; }$/;"	f	class:VecR
Set	vecr.h	/^	void Set (double X, double Y, double Z) {$/;"	f	class:VecR
SetAtoms	h2o.cpp	/^void Water::SetAtoms () {$/;"	f	class:Water
SetAtoms	h3o.cpp	/^void Hydronium::SetAtoms () {$/;"	f	class:Hydronium
SetAtoms	hno3.cpp	/^void Nitrate::SetAtoms () {$/;"	f	class:Nitrate
SetAtoms	hno3.cpp	/^void NitricAcid::SetAtoms () {$/;"	f	class:NitricAcid
SetAtoms	oh.cpp	/^void Hydroxide::SetAtoms () {$/;"	f	class:Hydroxide
SetBond	adjacencymatrix.cpp	/^void AdjacencyMatrix::SetBond (int x, int y, const double blength, const bondtype btype) {$/;"	f	class:AdjacencyMatrix
SetBond	adjacencymatrix.h	/^	void SetBond (Atom const * const a1, Atom const * const a2, const bondtype btype) {$/;"	f	class:AdjacencyMatrix
SetBondType	bond.cpp	/^void Bond::SetBondType (const bondtype btype) {$/;"	f	class:Bond
SetCharge	atom.cpp	/^void Atom::SetCharge () {$/;"	f	class:Atom
SetMass	atom.cpp	/^void Atom::SetMass () {$/;"	f	class:Atom
SetMoritaAxes	h2o.cpp	/^void Water::SetMoritaAxes (const int Zbond) {$/;"	f	class:Water
SetOrderAxes	h2o.cpp	/^void Water::SetOrderAxes () {$/;"	f	class:Water
Shift	atom.cpp	/^void Atom::Shift (VecR shift) {$/;"	f	class:Atom
Shift	molecule.cpp	/^void Molecule::Shift (VecR shift) {$/;"	f	class:Molecule
Size	atom.h	/^	static const VecR& Size ()	{ return _size; }$/;"	f	class:Atom
Size	atom.h	/^	static void Size (VecR size) { _size = size; }	\/\/ sets the system size$/;"	f	class:Atom
SliceWaterCoordination	watersystem.cpp	/^void WaterSystem::SliceWaterCoordination (const coordination coord) {$/;"	f	class:WaterSystem
SliceWaters	watersystem.cpp	/^void WaterSystem::SliceWaters (const double low, const double high) {$/;"	f	class:WaterSystem
Stat	ambermpisys.h	/^	MPI_Status * Stat () 		{ return &_stat; }$/;"	f	class:MPIMolSystem
SysDipoleCorrelation	wateranalyzer.h	/^trajectory WaterAnalyzer::SysDipoleCorrelation () {$/;"	f	class:WaterAnalyzer
System	wateranalyzer.h	/^	WaterSystem&	System() { return _sys; }$/;"	f	class:WaterAnalyzer
SystemDipole	xyzsystem.cpp	/^VecR XYZSystem::SystemDipole () {$/;"	f	class:XYZSystem
TOPFILE_H_	topfile.h	2;"	d
TOPFile	topfile.cpp	/^TOPFile::TOPFile () {$/;"	f	class:TOPFile
TOPFile	topfile.cpp	/^TOPFile::TOPFile (const TOPFile& topfile) :$/;"	f	class:TOPFile
TOPFile	topfile.cpp	/^TOPFile::TOPFile (std::string path) :$/;"	f	class:TOPFile
TOPFile	topfile.h	/^class TOPFile {$/;"	c
Tensor	dipolefieldtensor.h	/^	double const * Tensor () { return _tensor; }$/;"	f	class:DipoleFieldTensor
Theta_eq	moritasfg2002.h	/^const double Theta_eq 	= 104.51;		\/\/ in degrees$/;"	v
Trace	matrixr.cpp	/^double MatR::Trace () const {$/;"	f	class:MatR
Transpose	matrixr.cpp	/^MatR MatR::Transpose () const {$/;"	f	class:MatR
Ttensor	moritasfg2002.h	/^typedef std::vector< std::vector< MatR > > Ttensor;$/;"	t
UNBOUND	bond.h	/^	UNBOUND=0, O=1, OO=2, OOO=3, OOOO=4, 			\/\/ no H$/;"	e	enum:__anon3
UNBOUND	bondgraph.h	/^	UNBOUND=0, O=1, OO=2, OOO=3, OOOO=4, 			\/\/ no H$/;"	e	enum:__anon1
UNBOUND	connectmatrix.h	/^	UNBOUND=0, O=1, OO=2, OOO=3, OOOO=4, 			\/\/ no H$/;"	e	enum:__anon5
UNCOUPLED_OH_FREQ	watersfg.h	/^const double UNCOUPLED_OH_FREQ	= 3706.5\/AU2WAVENUMBER;			\/\/ the frequency of uncoupled OH bonds in the vapor phase (converted to frequency in atomic units)$/;"	v
UTILITY_H_	utility.h	2;"	d
Unit	vecr.cpp	/^VecR VecR::Unit () const {$/;"	f	class:VecR
Unset	molecule.h	/^	bool Unset () { _set = false; return (_set); }$/;"	f	class:Molecule
UpdateAlphaTensor	moritasfg2002.cpp	/^void MoritaSFG::UpdateAlphaTensor () {$/;"	f	class:MoritaSFG
UpdateCenterOfMass	molecule.cpp	/^VecR Molecule::UpdateCenterOfMass () {$/;"	f	class:Molecule
UpdateDipoleFieldTensor	moritasfg2002.cpp	/^void MoritaSFG::UpdateDipoleFieldTensor () {$/;"	f	class:MoritaSFG
UpdateGraph	bondgraph.cpp	/^void BondGraph::UpdateGraph (Atom_ptr_vec& atoms) {$/;"	f	class:BondGraph
UpdateMatrix	adjacencymatrix.cpp	/^void AdjacencyMatrix::UpdateMatrix (const Atom_ptr_vec& atoms) {$/;"	f	class:AdjacencyMatrix
UpdateMatrix	connectmatrix.cpp	/^void ConnectivityMatrix::UpdateMatrix () {$/;"	f	class:ConnectivityMatrix
UpdateMatrix	watersystem.h	/^	void UpdateMatrix () { matrix.UpdateMatrix (int_atoms); }$/;"	f	class:WaterSystem
VECR_H_	vecr.h	2;"	d
VecR	vecr.cpp	/^VecR::VecR () : _coords(Double_vector(3, 0.0)) {$/;"	f	class:VecR
VecR	vecr.cpp	/^VecR::VecR (const Double_vector& oldVec) : _coords(oldVec) {$/;"	f	class:VecR
VecR	vecr.cpp	/^VecR::VecR (const VecR& oldVec) : _coords(oldVec._coords) {$/;"	f	class:VecR
VecR	vecr.cpp	/^VecR::VecR (const double * vec) : _coords(Double_vector(3, 0.0)) {$/;"	f	class:VecR
VecR	vecr.cpp	/^VecR::VecR (const double X, const double Y, const double Z) : _coords(Double_vector(3,0.0)) {$/;"	f	class:VecR
VecR	vecr.h	/^class VecR {$/;"	c
WANNIER_BOND	wannier.h	9;"	d
WANNIER_H_	wannier.h	2;"	d
WATERSFG_H_	watersfg.h	2;"	d
WATERSYSTEM_H_	watersystem.h	2;"	d
WannierFile	wannier.cpp	/^WannierFile::WannierFile (std::string wannierpath) {$/;"	f	class:WannierFile
WannierFile	wannier.h	/^class WannierFile {$/;"	c
Wanniers	molecule.h	/^	const std::vector<VecR>& Wanniers ()		const { return _wanniers; }$/;"	f	class:Molecule
Wanniers	xyzsystem.h	/^	const std::vector<VecR>& Wanniers () const { return _wanniers.Coords(); }$/;"	f	class:XYZSystem
Water	h2o.cpp	/^Water::Water () : Molecule() {$/;"	f	class:Water
Water	h2o.cpp	/^Water::Water (const Molecule& molecule) : Molecule(molecule) {$/;"	f	class:Water
Water	h2o.h	/^class Water: public Molecule {$/;"	c
WaterAnalyzer	wateranalyzer.h	/^	WaterAnalyzer (WaterSystem& system) : _sys(system) {}		\/\/ Constructor that grabs the system and loads it up$/;"	f	class:WaterAnalyzer
WaterAnalyzer	wateranalyzer.h	/^class WaterAnalyzer {$/;"	c
WaterCoordination	adjacencymatrix.cpp	/^coordination AdjacencyMatrix::WaterCoordination (Water const * const wat) {$/;"	f	class:AdjacencyMatrix
WaterDipoleParms	dipoleparm.cpp	/^WaterDipoleParms::WaterDipoleParms (string parmpath="dipoleparm.dat") {$/;"	f	class:WaterDipoleParms
WaterDipoleParms	dipoleparm.h	/^class WaterDipoleParms {$/;"	c
WaterEigenSystem	watersfg.cpp	/^void SFGCalculator::WaterEigenSystem (Water& water) {$/;"	f	class:SFGCalculator
WaterSystem	watersystem.cpp	/^WaterSystem::WaterSystem (const WaterSystemParams& params) :$/;"	f	class:WaterSystem
WaterSystem	watersystem.cpp	/^WaterSystem::WaterSystem (const int argc, const char **argv, const WaterSystemParams& params) :$/;"	f	class:WaterSystem
WaterSystem	watersystem.h	/^class WaterSystem {$/;"	c
WaterSystemParams	watersystem.h	/^typedef struct WaterSystemParams {$/;"	s
Water_ptr_vec	h2o.h	/^typedef std::vector<Water *> Water_ptr_vec;$/;"	t
Water_ptr_vec	h3o.h	/^typedef std::vector<Water *> Water_ptr_vec;$/;"	t
Water_vec	h2o.h	/^typedef std::vector<Water> Water_vec;$/;"	t
Water_vec	h3o.h	/^typedef std::vector<Water> Water_vec;$/;"	t
WorldComm	ambermpisys.h	/^	MPI_Comm WorldComm () const { return _worldcomm; }$/;"	f	class:MPIMolSystem
Wrap	atom.cpp	/^void Atom::Wrap (VecR origin = VecR(0.0, 0.0, 0.0)) {$/;"	f	class:Atom
Wrap	vecr.cpp	/^VecR& VecR::Wrap (VecR& size, VecR origin) {$/;"	f	class:VecR
WritePDB	pdbfile.cpp	/^void PDBFile::WritePDB (vector<Molecule *> sys) {$/;"	f	class:PDBFile
X	atom.h	/^	double X () const 		{ return _position[x]; }$/;"	f	class:Atom
X	atom.h	/^	void X (double val) { _position.X(val); }			\/\/ for setting the atom's position$/;"	f	class:Atom
X	molecule.h	/^	VecR X () const					{ return _x; }$/;"	f	class:Molecule
X	vecr.h	/^	void X (const double val) { _coords[x] = val; }$/;"	f	class:VecR
XYZFILE_H_	xyzfile.h	2;"	d
XYZFile	xyzfile.cpp	/^XYZFile::XYZFile () {$/;"	f	class:XYZFile
XYZFile	xyzfile.cpp	/^XYZFile::XYZFile (std::string path) {$/;"	f	class:XYZFile
XYZFile	xyzfile.h	/^class XYZFile {$/;"	c
XYZSYSTEM_H_	xyzsystem.h	2;"	d
XYZSystem	xyzsystem.cpp	/^XYZSystem::XYZSystem (string filepath, VecR size, string wannierpath)$/;"	f	class:XYZSystem
XYZSystem	xyzsystem.h	/^class XYZSystem {$/;"	c
Y	atom.h	/^	double Y () const		{ return _position[y]; }$/;"	f	class:Atom
Y	atom.h	/^	void Y (double val) { _position.Y(val); }$/;"	f	class:Atom
Y	molecule.h	/^	VecR Y () const					{ return _y; }$/;"	f	class:Molecule
Y	vecr.h	/^	void Y (const double val) { _coords[y] = val; }$/;"	f	class:VecR
Z	atom.h	/^	double Z () const 		{ return _position[z]; }$/;"	f	class:Atom
Z	atom.h	/^	void Z (double val) { _position.Z(val); }$/;"	f	class:Atom
Z	molecule.h	/^	VecR Z () const					{ return _z; }$/;"	f	class:Molecule
Z	vecr.h	/^	void Z (const double val) { _coords[z] = val; }$/;"	f	class:VecR
ZCoordHistogram	wateranalyzer.h	/^vector< vector<int> > WaterAnalyzer::ZCoordHistogram ( double DZ ) {$/;"	f	class:WaterAnalyzer
Zero	matrixr.h	/^	void Zero () {								\/\/ Zero all elements of a matrix$/;"	f	class:MatR
Zero	vecr.cpp	/^void VecR::Zero () {$/;"	f	class:VecR
_A	moritasfg2002.h	/^	MatR					_A;$/;"	m	class:MoritaSFG
_AlphaDerivA	watersfg.h	/^	double _AlphaDerivA, _AlphaDerivS;$/;"	m	class:SFGCalculator
_AlphaDerivS	watersfg.h	/^	double _AlphaDerivA, _AlphaDerivS;$/;"	m	class:SFGCalculator
_Beta	watersfg.h	/^	std::vector< complex<double> > _Beta;		\/\/ hyperpolarizability of a given water (in the molecular frame)$/;"	m	class:SFGCalculator
_C1a	watersfg.h	/^	double _C1a, _C2a;		\/\/ and the anti-symmetric case$/;"	m	class:SFGCalculator
_C1s	watersfg.h	/^	double _C1s, _C2s;		\/\/ The coefficients that are solved for in the matrix equation (Eq. 8) for the symmetric case$/;"	m	class:SFGCalculator
_C2a	watersfg.h	/^	double _C1a, _C2a;		\/\/ and the anti-symmetric case$/;"	m	class:SFGCalculator
_C2s	watersfg.h	/^	double _C1s, _C2s;		\/\/ The coefficients that are solved for in the matrix equation (Eq. 8) for the symmetric case$/;"	m	class:SFGCalculator
_Chi	watersfg.h	/^	std::vector< complex<double> > _Chi;		\/\/ hyperpolarizability of a given water (in the molecular frame)$/;"	m	class:SFGCalculator
_DCM	watersfg.h	/^	MatR _DCM;				\/\/ rotation matrix for moving from the water molecular frame to the lab frame$/;"	m	class:SFGCalculator
_DENSITY_H_	density.h	2;"	d
_Data	dipoleparm.cpp	/^double * WaterDipoleParms::_Data (double r1, double r2, double theta) {$/;"	f	class:WaterDipoleParms
_FillBoxLattice	boxfiller.cpp	/^void BoxFiller::_FillBoxLattice () {$/;"	f	class:BoxFiller
_FillBoxRandom	boxfiller.cpp	/^void BoxFiller::_FillBoxRandom () {$/;"	f	class:BoxFiller
_FindBonds	connectmatrix.cpp	/^void ConnectivityMatrix::_FindBonds (Atom * atom1, Atom * atom2) {$/;"	f	class:ConnectivityMatrix
_FindEulerAngles	molecule.cpp	/^void Molecule::_FindEulerAngles () {$/;"	f	class:Molecule
_FindLastStep	pdbfile.cpp	/^int PDBFile::_FindLastStep () {$/;"	f	class:PDBFile
_FindSteps	xyzfile.cpp	/^void XYZFile::_FindSteps () {$/;"	f	class:XYZFile
_FormCovalentBond	connectmatrix.cpp	/^void ConnectivityMatrix::_FormCovalentBond (const Atom * atom1, const Atom * atom2) {$/;"	f	class:ConnectivityMatrix
_FormHBond	connectmatrix.cpp	/^void ConnectivityMatrix::_FormHBond (Atom * atom1, Atom * atom2) {$/;"	f	class:ConnectivityMatrix
_ID	atom.h	/^	int    _ID;				\/\/ some numerical identifier in case the atom is in an ordered list$/;"	m	class:Atom
_ID	molecule.h	/^	int				_ID;				\/\/ A numerical ID for the molecule$/;"	m	class:Molecule
_ID	wannier.h	/^	int				_ID;$/;"	m	class:WannierFile
_InitAtoms	ambermpisys.h	/^void MPIMolSystem::_InitAtoms () {$/;"	f	class:MPIMolSystem
_InitParams	boxfiller.cpp	/^void BoxFiller::_InitParams () {$/;"	f	class:BoxFiller
_LINALG_	matrixr.h	12;"	d
_MPIFinalize	ambermpisys.h	/^void MPIMolSystem::_MPIFinalize () {$/;"	f	class:MPIMolSystem
_MPISystemInit	ambermpisys.h	/^void MPIMolSystem::_MPISystemInit (int *argc, char ***argv) {$/;"	f	class:MPIMolSystem
_MolSystemInit	ambermpisys.h	/^void MPIMolSystem::_MolSystemInit (string prmtop, string mdcrd, string mdvel) {$/;"	f	class:MPIMolSystem
_MuDerivA	watersfg.h	/^	double _MuDerivA, _MuDerivS;			\/\/ the total mu derivative with the eigenvector weighting from Eq 7.$/;"	m	class:SFGCalculator
_MuDerivS	watersfg.h	/^	double _MuDerivA, _MuDerivS;			\/\/ the total mu derivative with the eigenvector weighting from Eq 7.$/;"	m	class:SFGCalculator
_N	moritasfg2002.h	/^	int						_N;		\/\/ number of waters$/;"	m	class:MoritaSFG
_OH1FreqShift	watersfg.h	/^	double _OH1FreqShift, _OH2FreqShift;		\/\/ The two frequency shift values calculated from the forces on the OH bonds$/;"	m	class:SFGCalculator
_OH2FreqShift	watersfg.h	/^	double _OH1FreqShift, _OH2FreqShift;		\/\/ The two frequency shift values calculated from the forces on the OH bonds$/;"	m	class:SFGCalculator
_ParseAtom	pdbfile.cpp	/^Atom *PDBFile::_ParseAtom (const char *atomEntry) {$/;"	f	class:PDBFile
_ParseAtomInformation	ambersystem.cpp	/^void AmberSystem::_ParseAtomInformation () {$/;"	f	class:AmberSystem
_ParseAtomVectors	ambersystem.cpp	/^void AmberSystem::_ParseAtomVectors () {$/;"	f	class:AmberSystem
_ParseFile	complexdatafile.cpp	/^void ComplexDataFile::_ParseFile () {$/;"	f	class:ComplexDataFile
_ParseMolecules	ambersystem.cpp	/^void AmberSystem::_ParseMolecules () {$/;"	f	class:AmberSystem
_ParseMolecules	xyzsystem.cpp	/^void XYZSystem::_ParseMolecules () {$/;"	f	class:XYZSystem
_ParseMols	ambermpisys.h	/^void MPIMolSystem::_ParseMols () {$/;"	f	class:MPIMolSystem
_ParseWanniers	xyzsystem.cpp	/^void XYZSystem::_ParseWanniers () {$/;"	f	class:XYZSystem
_T	moritasfg2002.h	/^	Dbl_mtr					_T;		\/\/ Dipole field tensor$/;"	m	class:MoritaSFG
_T_set	moritasfg2002.h	/^	bool					_T_set;$/;"	m	class:MoritaSFG
_UpdateCoords	ambermpisys.h	/^void MPIMolSystem::_UpdateCoords () {$/;"	f	class:MPIMolSystem
_alpha	h2o.h	/^	MatR _alpha;					\/\/ polarizability of the molecule$/;"	m	class:Water
_alpha	moritasfg2002.h	/^	Dbl_mtr					_alpha;	\/\/ polarizabilities of the waters$/;"	m	class:MoritaSFG
_alphe_eff	moritasfg2002.h	/^	Dbl_mtr					_alphe_eff;		\/\/ effective polarizability taking into account the local-field$/;"	m	class:MoritaSFG
_atomnames	topfile.h	/^	std::vector<std::string> _atomnames;		\/\/ The listing of the atoms in the file$/;"	m	class:TOPFile
_atoms	adjacencymatrix.h	/^	Atom_ptr_vec	_atoms;		\/\/ the atoms in the system$/;"	m	class:AdjacencyMatrix
_atoms	ambermpisys.h	/^	vector<Atom> _atoms;$/;"	m	class:MPIMolSystem
_atoms	ambersystem.h	/^	Atom_ptr_vec _atoms;			\/\/ A listing of all the atoms in the system with information parsed from the topfile and crdfile$/;"	m	class:AmberSystem
_atoms	connectmatrix.h	/^	Atom **		_atoms;			\/\/ the atoms in the system$/;"	m	class:AdjacencyMatrix
_atoms	molecule.h	/^	Atom_ptr_vec 		_atoms;				\/\/ the list of the atoms in the molecule$/;"	m	class:Molecule
_atoms	pdbfile.h	/^	vector<Atom *> _atoms;$/;"	m	class:PDBFile
_atoms	xyzfile.h	/^	std::vector<Atom *> _atoms;		\/\/ The listing of the atoms in the file$/;"	m	class:XYZFile
_atoms	xyzsystem.h	/^	XYZFile				_atoms;			\/\/ Atomlist parsed from an xyz file$/;"	m	class:XYZSystem
_binSize	histogram.h	/^	double _binSize;$/;"	m	class:Histogram
_boxSize	boxfiller.h	/^	VecR	_boxSize;	\/\/ system size$/;"	m	class:BoxFiller
_built	adjacencymatrix.h	/^	bool 			_built;		\/\/ has the matrix been built to the current size?$/;"	m	class:AdjacencyMatrix
_centerofmass	molecule.h	/^	VecR			_centerofmass;		\/\/ calculate by 1\/M * Sum(m[i]*r[i])	where M = total mass, m[i] and r[i] are atom mass and pos$/;"	m	class:Molecule
_charge	atom.h	/^		   _charge;$/;"	m	class:Atom
_charge	molecule.h	/^	double			_charge;$/;"	m	class:Molecule
_charges	topfile.h	/^	std::vector<double> _charges;		\/\/ atomic charges$/;"	m	class:TOPFile
_complex	complexdatafile.h	/^	std::vector<std::complex<double> > 	_complex;$/;"	m	class:ComplexDataFile
_coord_names	bondgraph.h	/^	coord_map _coord_names;$/;"	m	class:BondGraph
_coords	ambersystem.h	/^	CRDFile		_coords;$/;"	m	class:AmberSystem
_coords	crdfile.h	/^	std::vector<VecR>	_coords;	\/\/ atomic coordinates$/;"	m	class:CRDFile
_coords	vecr.h	/^	Double_vector		_coords;$/;"	m	class:VecR
_coords	wannier.h	/^	std::vector<VecR>	_coords;	\/\/ atomic coordinates$/;"	m	class:WannierFile
_copy	molecule.h	/^	bool			_copy;				\/\/ this gets set if the molecule is a copy of a previous molecule$/;"	m	class:Molecule
_currentstep	pdbfile.h	/^		_currentstep;$/;"	m	class:PDBFile
_currentstep	xyzfile.h	/^	int _currentstep, _firstStep, _lastStep, _numSteps,$/;"	m	class:XYZFile
_data	complexdatafile.h	/^	std::vector<double>			_data;$/;"	m	class:ComplexDataFile
_data	dipoleparm.h	/^	double			****_data;		\/\/ pointer arrays that will get us the data we need$/;"	m	class:WaterDipoleParms
_dims	crdfile.h	/^	VecR			_dims;		\/\/ Dimensions of the system (box size)$/;"	m	class:CRDFile
_dims	xyzsystem.h	/^	VecR	_dims;			\/\/ A vector holding the system size (dimensions)$/;"	m	class:XYZSystem
_dipole	molecule.h	/^	VecR			_dipole;			\/\/ the molecular dipole$/;"	m	class:Molecule
_dipparms	h2o.h	/^	static WaterDipoleParms _dipparms;		\/\/ The water dipole parameter file$/;"	m	class:Water
_distance	dipolefieldtensor.h	/^	double _distance;	\/\/ scalar distance between the two molecules$/;"	m	class:DipoleFieldTensor
_dr	dipoleparm.h	/^	double			_dr[3];				\/\/ bin size$/;"	m	class:WaterDipoleParms
_edges	bondgraph.h	/^	Bond_ptr_list		_edges;$/;"	m	class:BondGraph
_edges	graph.h	/^	Edge_ptr_list		_edges;$/;"	m	class:Graph
_eigenset	matrixr.h	/^	bool _eigenset;$/;"	m	class:MatR
_eigenvalsI	matrixr.h	/^	double _eigenvalsI[3];$/;"	m	class:MatR
_eigenvalsR	matrixr.h	/^	double _eigenvalsR[3];$/;"	m	class:MatR
_eigenvecs	matrixr.h	/^	double _eigenvecs[9];$/;"	m	class:MatR
_eof	crdfile.h	/^	bool			_eof;		\/\/ end of file marker for the coord file$/;"	m	class:CRDFile
_eof	forcefile.h	/^	bool			_eof;		\/\/ end of file marker for the force file$/;"	m	class:ForceFile
_eof	wannier.h	/^	bool			_eof;		\/\/ end of file marker for the coord file$/;"	m	class:WannierFile
_eulerangles	molecule.h	/^	double			_eulerangles[3];	\/\/ the three euler angles theta, phi, chi$/;"	m	class:Molecule
_file	complexdatafile.h	/^	std::ifstream				_file;$/;"	m	class:ComplexDataFile
_file	crdfile.h	/^	FILE 			*_file;$/;"	m	class:CRDFile
_file	dipoleparm.h	/^	FILE 			*_file;$/;"	m	class:WaterDipoleParms
_file	forcefile.h	/^	FILE 			*_file;$/;"	m	class:ForceFile
_file	pdbfile.h	/^	FILE *_file;				\/\/ the PDB file listing all the atom coordinates$/;"	m	class:PDBFile
_file	wannier.h	/^	FILE *			_file;$/;"	m	class:WannierFile
_file	xyzfile.h	/^	FILE *_file;				\/\/ the XYZ file listing all the atom coordinates$/;"	m	class:XYZFile
_firstStep	xyzfile.h	/^	int _currentstep, _firstStep, _lastStep, _numSteps,$/;"	m	class:XYZFile
_force	atom.h	/^	VecR _force;			\/\/ the external force on the atom at any given point in time$/;"	m	class:Atom
_forces	ambermpisys.h	/^	double * _forces;$/;"	m	class:MPIMolSystem
_forces	ambersystem.h	/^	ForceFile	_forces;$/;"	m	class:AmberSystem
_forces	forcefile.h	/^	std::vector<VecR>	_forces;	\/\/ atomic coordinates$/;"	m	class:ForceFile
_frame	crdfile.h	/^	int 			_frame;		\/\/ The current frame (number of timesteps processed)$/;"	m	class:CRDFile
_frame	forcefile.h	/^	int 			_frame;		\/\/ The current frame (number of timesteps processed)$/;"	m	class:ForceFile
_frame	wannier.h	/^	int 			_frame;		\/\/ The current frame (number of timesteps processed)$/;"	m	class:WannierFile
_h	hno3.h	/^	Atom *_oh, *_n, *_h, *_o1, *_o2;		\/\/ Pointers to the various atoms in the nitric acid. These are static for no$/;"	m	class:NitricAcid
_h	oh.h	/^	Atom *_o, *_h;			\/\/ pointers to the atoms for easy access$/;"	m	class:Hydroxide
_h1	h2o.h	/^	Atom *_o, *_h1, *_h2;			\/\/ pointers to the atoms for easy access$/;"	m	class:Water
_h1	h3o.h	/^	Atom *_o, *_h1, *_h2, *_h3;			\/\/ pointers to the atoms for easy access$/;"	m	class:Hydronium
_h2	h2o.h	/^	Atom *_o, *_h1, *_h2;			\/\/ pointers to the atoms for easy access$/;"	m	class:Water
_h2	h3o.h	/^	Atom *_o, *_h1, *_h2, *_h3;			\/\/ pointers to the atoms for easy access$/;"	m	class:Hydronium
_h3	h3o.h	/^	Atom *_o, *_h1, *_h2, *_h3;			\/\/ pointers to the atoms for easy access$/;"	m	class:Hydronium
_histogram	histogram.h	/^	vector<int> _histogram;$/;"	m	class:Histogram
_id	ambermpisys.h	/^	int _id, _p;		\/\/ mpi rank of the process, and total number of processes$/;"	m	class:MPIMolSystem
_initialized	xyzfile.h	/^	bool _initialized;				\/\/ To tell wether or not a file has been loaded$/;"	m	class:XYZFile
_initstep	pdbfile.h	/^	int _initstep,				\/\/ the first frame listed in the file$/;"	m	class:PDBFile
_lastStep	xyzfile.h	/^	int _currentstep, _firstStep, _lastStep, _numSteps,$/;"	m	class:XYZFile
_laststep	pdbfile.h	/^		_laststep,$/;"	m	class:PDBFile
_loaded	forcefile.h	/^	bool			_loaded;$/;"	m	class:ForceFile
_loaded	pdbfile.h	/^	int _loaded;				\/\/ To tell wether or not a file has been loaded$/;"	m	class:PDBFile
_loaded	wannier.h	/^	bool			_loaded;	\/\/ tells wether or not the wannier file is being used or not (or if it exists)$/;"	m	class:WannierFile
_mass	atom.h	/^	double _mass,$/;"	m	class:Atom
_mass	molecule.h	/^	double			_mass;				\/\/ Total molecular mass$/;"	m	class:Molecule
_masses	topfile.h	/^	std::vector<double> _masses;			\/\/ atomic masses$/;"	m	class:TOPFile
_master	ambermpisys.h	/^	bool _master;	\/\/ sets the alias for the master$/;"	m	class:MPIMolSystem
_matrix	adjacencymatrix.h	/^	Bond_matrix		_matrix;	\/\/ the actual data structure for storing connection data$/;"	m	class:AdjacencyMatrix
_matrix	connectmatrix.h	/^	double **	_matrix;		\/\/ the actual data structure for storing connection data$/;"	m	class:AdjacencyMatrix
_matrix	matrixr.h	/^	Double_matrix	_matrix;$/;"	m	class:MatR
_matrix	watersfg.h	/^	AdjacencyMatrix * _matrix;		\/\/ a connectivity matrix for analyzing water-bonding$/;"	m	class:SFGCalculator
_matrix	xyzsystem.h	/^	AdjacencyMatrix		_matrix;$/;"	m	class:XYZSystem
_max	dipoleparm.h	/^	double			_max[3];$/;"	m	class:WaterDipoleParms
_max	histogram.h	/^	double _max;$/;"	m	class:Histogram
_min	dipoleparm.h	/^	double			_min[3];			\/\/ min and max values of the bins for the three parameters$/;"	m	class:WaterDipoleParms
_min	histogram.h	/^	double _min;$/;"	m	class:Histogram
_molPlane	hno3.h	/^	VecR _molPlane;$/;"	m	class:Nitrate
_molPlane	hno3.h	/^	VecR _molPlane;$/;"	m	class:NitricAcid
_molecules	pdbfile.h	/^	vector<Molecule *> _molecules;		\/\/ The listing of the molecules in the file$/;"	m	class:PDBFile
_molid	atom.h	/^	int	   _molid;		\/\/ the molecule that contains this atom$/;"	m	class:Atom
_molnames	topfile.h	/^	std::vector<std::string> _molnames;		\/\/ molecule names$/;"	m	class:TOPFile
_molpointers	topfile.h	/^	std::vector<int>	_molpointers;	\/\/ prmtop pointers to each molecule (the location in the prmtop file, not c-style)$/;"	m	class:TOPFile
_mols	ambermpisys.h	/^	vector<Molecule> _mols;$/;"	m	class:MPIMolSystem
_mols	ambersystem.h	/^	Mol_ptr_vec _mols;		\/\/ The molecules within a system - defined by the residues in the topology files$/;"	m	class:AmberSystem
_mols	boxfiller.h	/^	vector<Molecule>	_mols;$/;"	m	class:BoxFiller
_mols	xyzsystem.h	/^	vector<Molecule *> 	_mols;			\/\/ once we have atoms defined, we form them into molecules$/;"	m	class:XYZSystem
_molsizes	topfile.h	/^	std::vector<int>	_molsizes;		\/\/ the number of atoms in each molecule$/;"	m	class:TOPFile
_n	hno3.h	/^	Atom *_n, *_o1, *_o2, *_o3;		\/\/ Pointers to the various atoms in the nitric acid. These are static for no$/;"	m	class:Nitrate
_n	hno3.h	/^	Atom *_oh, *_n, *_h, *_o1, *_o2;		\/\/ Pointers to the various atoms in the nitric acid. These are static for no$/;"	m	class:NitricAcid
_name	atom.h	/^	std::string _name,$/;"	m	class:Atom
_name	molecule.h	/^	string			_name;				\/\/ some text ID or name for the molecule$/;"	m	class:Molecule
_no1	hno3.h	/^	VecR	_no1, _no2, _no3;		\/\/ vectors of the N-O bonds$/;"	m	class:Nitrate
_no2	hno3.h	/^	VecR	_no1, _no2, _no3;		\/\/ vectors of the N-O bonds$/;"	m	class:Nitrate
_no2dipole	hno3.h	/^	VecR _no2dipole;$/;"	m	class:NitricAcid
_no2wanniers	hno3.h	/^	std::vector<VecR> _no2wanniers;$/;"	m	class:NitricAcid
_no3	hno3.h	/^	VecR	_no1, _no2, _no3;		\/\/ vectors of the N-O bonds$/;"	m	class:Nitrate
_nodes	bondgraph.h	/^	AtomNode_ptr_list	_nodes;$/;"	m	class:BondGraph
_nodes	graph.h	/^	Node_ptr_list		_nodes;$/;"	m	class:Graph
_numAtoms	ambermpisys.h	/^	int			_numAtoms;		\/\/ number of atoms in the system - for all the nodes to know$/;"	m	class:MPIMolSystem
_numAtoms	pdbfile.h	/^	int	_numAtoms;				\/\/ total number of atoms in the system$/;"	m	class:PDBFile
_numAtoms	topfile.h	/^	int _numAtoms;$/;"	m	class:TOPFile
_numBins	histogram.h	/^	double _numBins;$/;"	m	class:Histogram
_numMols	ambermpisys.h	/^	int			_numMols;		\/\/ number of molecules in the system$/;"	m	class:MPIMolSystem
_numMols	pdbfile.h	/^	int _numMols;$/;"	m	class:PDBFile
_numMols	topfile.h	/^	int _numMols;$/;"	m	class:TOPFile
_numSteps	xyzfile.h	/^	int _currentstep, _firstStep, _lastStep, _numSteps,$/;"	m	class:XYZFile
_num_bins	dipoleparm.h	/^	int 			_num_bins[3];		\/\/ number of bins for each of the three parameters$/;"	m	class:WaterDipoleParms
_numatoms	xyzfile.h	/^		_numatoms;				\/\/ total number of centers to process from the file for the frame$/;"	m	class:XYZFile
_o	h2o.h	/^	Atom *_o, *_h1, *_h2;			\/\/ pointers to the atoms for easy access$/;"	m	class:Water
_o	h3o.h	/^	Atom *_o, *_h1, *_h2, *_h3;			\/\/ pointers to the atoms for easy access$/;"	m	class:Hydronium
_o	oh.h	/^	Atom *_o, *_h;			\/\/ pointers to the atoms for easy access$/;"	m	class:Hydroxide
_o1	hno3.h	/^	Atom *_n, *_o1, *_o2, *_o3;		\/\/ Pointers to the various atoms in the nitric acid. These are static for no$/;"	m	class:Nitrate
_o1	hno3.h	/^	Atom *_oh, *_n, *_h, *_o1, *_o2;		\/\/ Pointers to the various atoms in the nitric acid. These are static for no$/;"	m	class:NitricAcid
_o2	hno3.h	/^	Atom *_n, *_o1, *_o2, *_o3;		\/\/ Pointers to the various atoms in the nitric acid. These are static for no$/;"	m	class:Nitrate
_o2	hno3.h	/^	Atom *_oh, *_n, *_h, *_o1, *_o2;		\/\/ Pointers to the various atoms in the nitric acid. These are static for no$/;"	m	class:NitricAcid
_o3	hno3.h	/^	Atom *_n, *_o1, *_o2, *_o3;		\/\/ Pointers to the various atoms in the nitric acid. These are static for no$/;"	m	class:Nitrate
_oh	hno3.h	/^	Atom *_oh, *_n, *_h, *_o1, *_o2;		\/\/ Pointers to the various atoms in the nitric acid. These are static for no$/;"	m	class:NitricAcid
_oh	oh.h	/^	VecR _oh;				\/\/ The OH bond vector$/;"	m	class:Hydroxide
_oh1	h2o.h	/^	VecR _oh1, _oh2;				\/\/ Both of the OH vectors$/;"	m	class:Water
_oh1	h3o.h	/^	VecR _oh1, _oh2, _oh3;				\/\/ Both of the OH vectors$/;"	m	class:Hydronium
_oh2	h2o.h	/^	VecR _oh1, _oh2;				\/\/ Both of the OH vectors$/;"	m	class:Water
_oh2	h3o.h	/^	VecR _oh1, _oh2, _oh3;				\/\/ Both of the OH vectors$/;"	m	class:Hydronium
_oh3	h3o.h	/^	VecR _oh1, _oh2, _oh3;				\/\/ Both of the OH vectors$/;"	m	class:Hydronium
_p	ambermpisys.h	/^	int _id, _p;		\/\/ mpi rank of the process, and total number of processes$/;"	m	class:MPIMolSystem
_p	moritasfg2002.h	/^	VecR					_p;		\/\/ vector of dipoles of all the waters$/;"	m	class:MoritaSFG
_params	boxfiller.h	/^	FILE * _params;$/;"	m	class:BoxFiller
_parsed	xyzsystem.h	/^	bool _parsed;$/;"	m	class:XYZSystem
_path	pdbfile.h	/^	string _path;$/;"	m	class:PDBFile
_path	xyzfile.h	/^	std::string _path;$/;"	m	class:XYZFile
_pdb	boxfiller.h	/^	PDBFile _pdb;		\/\/ pdb file containing all the atoms\/molecules$/;"	m	class:BoxFiller
_pmolecule	atom.h	/^	Molecule * _pmolecule;$/;"	m	class:Atom
_position	atom.h	/^	VecR _position;			\/\/ Particle position$/;"	m	class:Atom
_positions	ambermpisys.h	/^	double * _positions;$/;"	m	class:MPIMolSystem
_r	dipolefieldtensor.h	/^	double const * _r;	\/\/ distance vector (x,y,z) between 2 molecules$/;"	m	class:DipoleFieldTensor
_residue	atom.h	/^		   _residue;$/;"	m	class:Atom
_residueNames	boxfiller.h	/^	vector<string>	_residueNames;$/;"	m	class:BoxFiller
_residueNum	boxfiller.h	/^	vector<int>		_residueNum;$/;"	m	class:BoxFiller
_set	hno3.h	/^	bool _set;								\/\/ to let us know if the atom have been set in the molecule$/;"	m	class:Nitrate
_set	hno3.h	/^	bool _set;								\/\/ to let us know if the atom have been set in the molecule$/;"	m	class:NitricAcid
_set	molecule.h	/^	bool			_set;				\/\/ just a little helper to see if the atoms of the molecule have been set or for any other special purpose$/;"	m	class:Molecule
_set	watersfg.h	/^	bool 	_set;			\/\/ set when the water molecule has already gone through prelim calculations that don't need to be repeated for each calculation of Beta$/;"	m	class:SFGCalculator
_size	adjacencymatrix.h	/^	int 			_size;$/;"	m	class:AdjacencyMatrix
_size	atom.h	/^	static VecR _size;				\/\/ system size$/;"	m	class:Atom
_size	crdfile.h	/^	int 			_size;		\/\/ number of atoms in the system$/;"	m	class:CRDFile
_size	forcefile.h	/^	int 			_size;		\/\/ number of atoms in the system$/;"	m	class:ForceFile
_size	wannier.h	/^	int 			_size;		\/\/ number of lines to process from the wannier file per frame$/;"	m	class:WannierFile
_spacing	boxfiller.h	/^	double	_spacing;$/;"	m	class:BoxFiller
_stat	ambermpisys.h	/^	MPI_Status _stat;$/;"	m	class:MPIMolSystem
_sys	ambermpisys.h	/^	AmberSystem * _sys;			\/\/ the amber system object for the master node$/;"	m	class:MPIMolSystem
_sys	wateranalyzer.h	/^	WaterSystem&			_sys;		\/\/ the water system that will be used for calculations$/;"	m	class:WaterAnalyzer
_tensor	dipolefieldtensor.h	/^	double _tensor[9];	\/\/ The internal elements of the dipole field tensor$/;"	m	class:DipoleFieldTensor
_topfile	ambersystem.h	/^	TOPFile		_topfile;$/;"	m	class:AmberSystem
_topfile	topfile.h	/^	FILE * _topfile;			\/\/ The associated topology file output by AMBER$/;"	m	class:TOPFile
_voh	hno3.h	/^	VecR _voh;$/;"	m	class:NitricAcid
_w1	watersfg.h	/^	double _w1, _w2;		\/\/ Shifted frequency values from the gas phase vibration frequency$/;"	m	class:SFGCalculator
_w2	watersfg.h	/^	double _w1, _w2;		\/\/ Shifted frequency values from the gas phase vibration frequency$/;"	m	class:SFGCalculator
_wa	watersfg.h	/^	double _ws, _wa;		\/\/ The two normal mode (symmetric and antisymmetric) frequencies of the water molecule$/;"	m	class:SFGCalculator
_wanniers	molecule.h	/^	std::vector<VecR>	_wanniers;			\/\/ the wannier centers in the molecule$/;"	m	class:Molecule
_wanniers	xyzsystem.h	/^	WannierFile 		_wanniers;		\/\/ The wannier centers$/;"	m	class:XYZSystem
_wats	moritasfg2002.h	/^	std::vector<Water *>	_wats;	\/\/ waters of the system$/;"	m	class:MoritaSFG
_worldcomm	ambermpisys.h	/^	MPI_Comm _worldcomm;$/;"	m	class:MPIMolSystem
_ws	watersfg.h	/^	double _ws, _wa;		\/\/ The two normal mode (symmetric and antisymmetric) frequencies of the water molecule$/;"	m	class:SFGCalculator
_x	molecule.h	/^	VecR			_x, _y, _z;			\/\/ molecular frame axes$/;"	m	class:Molecule
_y	molecule.h	/^	VecR			_x, _y, _z;			\/\/ molecular frame axes$/;"	m	class:Molecule
_z	molecule.h	/^	VecR			_x, _y, _z;			\/\/ molecular frame axes$/;"	m	class:Molecule
atom	bondgraph.h	/^	Atom * atom;$/;"	m	class:AtomNode
avg	watersystem.h	/^	bool avg;$/;"	m	struct:WaterSystemParams
axis	watersystem.h	/^	coord axis;$/;"	m	class:WaterSystem
axis	watersystem.h	/^	coord axis;$/;"	m	struct:WaterSystemParams
bond	bond.h	/^	bondtype bond;	 	\/\/ bond type (covalent, hydrogen-bond, or unbonded)$/;"	m	class:Bond
bondlength	bond.h	/^	double	bondlength;	\/\/ bond length$/;"	m	class:Bond
bondtype	bond.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded, covalent} bondtype;$/;"	t	typeref:enum:__anon4
bondtype	bondgraph.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded} bondtype;$/;"	t	typeref:enum:__anon2
bondtype	connectmatrix.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded} bondtype;$/;"	t	typeref:enum:__anon6
clear	molecule.cpp	/^void Molecule::clear () {$/;"	f	class:Molecule
coord	vecr.h	/^enum coord {x=0, y=1, z=2};$/;"	g
coord_map	bond.h	/^typedef std::map<coordination, std::string> coord_map;$/;"	t
coord_map	bondgraph.h	/^typedef std::map<coordination, string> coord_map;$/;"	t
coord_map	connectmatrix.h	/^typedef std::map<coordination, string> coord_map;$/;"	t
coordination	bond.h	/^} coordination;$/;"	t	typeref:enum:__anon3
coordination	bondgraph.h	/^} coordination;$/;"	t	typeref:enum:__anon1
coordination	connectmatrix.h	/^} coordination;$/;"	t	typeref:enum:__anon5
covalent	bond.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded, covalent} bondtype;$/;"	e	enum:__anon4
edges	bondgraph.h	/^	Bond_ptr_list	edges;$/;"	m	class:AtomNode
edges	node.h	/^	Edge_ptr_list edges;		\/\/ all the edges connecting to this node$/;"	m	class:Node
element	matrixr.h	/^enum element {xx=0, yx=1, zx=2, xy=3, yy=4, zy=5, xz=6, yz=7, zz=8};$/;"	g
eof	ambersystem.h	/^	bool eof () { return _coords.eof(); }$/;"	f	class:AmberSystem
eof	crdfile.h	/^	bool eof () 	const { return _eof; }$/;"	f	class:CRDFile
eof	forcefile.h	/^	bool eof () 	{ return _eof; }$/;"	f	class:ForceFile
eof	wannier.h	/^	bool eof () 	const { return _eof; }		\/\/ have we reached the end of the file?$/;"	f	class:WannierFile
hbond	bond.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded, covalent} bondtype;$/;"	e	enum:__anon4
hbond	bondgraph.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded} bondtype;$/;"	e	enum:__anon2
hbond	connectmatrix.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded} bondtype;$/;"	e	enum:__anon6
int_atoms	watersystem.h	/^	Atom_ptr_vec	int_atoms;		\/\/ interfacial water atoms (or as above)$/;"	m	class:WaterSystem
int_high	watersystem.h	/^	double int_low, int_high, middle;		\/\/ the positions of analysis cutoffs$/;"	m	class:WaterSystem
int_low	watersystem.h	/^	double int_low, int_high, middle;		\/\/ the positions of analysis cutoffs$/;"	m	class:WaterSystem
int_mols	watersystem.h	/^	Water_ptr_vec	int_mols;		\/\/ interfacial waters, or just all the waters in the system depending on the function call$/;"	m	class:WaterSystem
k0	watersfg.h	/^const double k0	=	0.548;		\/\/ atomic units (force\/length) Eh\/ao\/ao$/;"	v
l	watersfg.h	/^const double l	=	-1.991;		\/\/ atomic units (force\/length^2)	Eh\/ao\/ao\/ao... yikes$/;"	v
main	complexdatafile.cpp	/^int main (int argc, char **argv) {$/;"	f
matrix	watersystem.h	/^	AdjacencyMatrix	matrix;$/;"	m	class:WaterSystem
maxdistance	rdf.h	6;"	d
mdcrd	watersystem.h	/^	string prmtop, mdcrd, mdvel;$/;"	m	struct:WaterSystemParams
mdvel	watersystem.h	/^	string prmtop, mdcrd, mdvel;$/;"	m	struct:WaterSystemParams
middle	watersystem.h	/^	double int_low, int_high, middle;		\/\/ the positions of analysis cutoffs$/;"	m	class:WaterSystem
nhbond	bond.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded, covalent} bondtype;$/;"	e	enum:__anon4
nhbond	bondgraph.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded} bondtype;$/;"	e	enum:__anon2
nhbond	connectmatrix.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded} bondtype;$/;"	e	enum:__anon6
nobond	bond.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded, covalent} bondtype;$/;"	e	enum:__anon4
nobond	bondgraph.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded} bondtype;$/;"	e	enum:__anon2
nobond	connectmatrix.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded} bondtype;$/;"	e	enum:__anon6
numAtoms	pdbfile.h	/^	int numAtoms () { return _numAtoms; }$/;"	f	class:PDBFile
numHydroniums	h3o.cpp	/^int Hydronium::numHydroniums = 0;$/;"	m	class:Hydronium	file:
numHydroniums	h3o.h	/^	static int numHydroniums;			\/\/ total number of waters in the system$/;"	m	class:Hydronium
numHydroxides	oh.cpp	/^int Hydroxide::numHydroxides = 0;$/;"	m	class:Hydroxide	file:
numHydroxides	oh.h	/^	static int numHydroxides;			\/\/ total number of waters in the system$/;"	m	class:Hydroxide
numMolecules	molecule.cpp	/^int Molecule::numMolecules = 0;$/;"	m	class:Molecule	file:
numMolecules	molecule.h	/^	static int numMolecules;$/;"	m	class:Molecule
numMols	pdbfile.h	/^	int numMols () { return _numMols; }$/;"	f	class:PDBFile
numNitrates	hno3.cpp	/^int Nitrate::numNitrates = 0;$/;"	m	class:Nitrate	file:
numNitrates	hno3.h	/^	static int numNitrates;$/;"	m	class:Nitrate
numNitricAcids	hno3.cpp	/^int NitricAcid::numNitricAcids = 0;$/;"	m	class:NitricAcid	file:
numNitricAcids	hno3.h	/^	static int numNitricAcids;$/;"	m	class:NitricAcid
numWaters	h2o.cpp	/^int Water::numWaters = 0;$/;"	m	class:Water	file:
numWaters	h2o.h	/^	static int numWaters;			\/\/ total number of waters in the system$/;"	m	class:Water
num_bonds	bond.cpp	/^int Bond::num_bonds = 0;$/;"	m	class:Bond	file:
num_bonds	bond.h	/^	static int num_bonds;$/;"	m	class:Bond
num_edges	edge.cpp	/^int Edge::num_edges = 0;$/;"	m	class:Edge	file:
num_edges	edge.h	/^	static int num_edges;$/;"	m	class:Edge
num_nodes	node.cpp	/^int Node::num_nodes = 0;$/;"	m	class:Node	file:
num_nodes	node.h	/^	static int num_nodes;$/;"	m	class:Node
ohbond	bond.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded, covalent} bondtype;$/;"	e	enum:__anon4
ohbond	bondgraph.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded} bondtype;$/;"	e	enum:__anon2
ohbond	connectmatrix.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded} bondtype;$/;"	e	enum:__anon6
operator %	vecr.cpp	/^VecR VecR::operator% (const VecR& input) const {$/;"	f	class:VecR
operator ()	matrixr.cpp	/^double MatR::operator() (coord const row, coord const col) const {$/;"	f	class:MatR
operator ()	matrixr.cpp	/^double MatR::operator() (int const row, int const col) const {$/;"	f	class:MatR
operator ()	vecr.cpp	/^double VecR::operator() (const coord index) const {$/;"	f	class:VecR
operator ()	vecr.cpp	/^double VecR::operator() (const int index) const {$/;"	f	class:VecR
operator *	matrixr.cpp	/^MatR MatR::operator* (const MatR& input) const {		\/\/ Matrix rotation\/multiplication$/;"	f	class:MatR
operator *	matrixr.cpp	/^VecR MatR::operator* (const VecR& input) const {		\/\/ Vector rotation\/matrix-vector inner product$/;"	f	class:MatR
operator *	vecr.cpp	/^VecR VecR::operator* (const double input) const {$/;"	f	class:VecR
operator *	vecr.cpp	/^double VecR::operator* (const VecR& input) const {$/;"	f	class:VecR
operator *=	vecr.cpp	/^void VecR::operator*= (const double input) {$/;"	f	class:VecR
operator +	matrixr.cpp	/^MatR MatR::operator+ (const MatR& input) const {$/;"	f	class:MatR
operator +	vecr.cpp	/^VecR VecR::operator+ (const VecR& input) const {$/;"	f	class:VecR
operator ++	histogram.h	/^	int 	operator++ (int bin) { _histogram[bin]++; }$/;"	f	class:Histogram
operator +=	vecr.cpp	/^void VecR::operator+= (const VecR& input) {$/;"	f	class:VecR
operator +=	vecr.cpp	/^void VecR::operator+= (const double input) {$/;"	f	class:VecR
operator -	atom.cpp	/^double Atom::operator- (const Atom& input) const {$/;"	f	class:Atom
operator -	vecr.cpp	/^VecR VecR::operator- (const VecR& input) const {$/;"	f	class:VecR
operator --	histogram.h	/^	int 	operator-- (int bin) { _histogram[bin]--; }$/;"	f	class:Histogram
operator -=	vecr.cpp	/^void VecR::operator-= (const VecR& input) {$/;"	f	class:VecR
operator -=	vecr.cpp	/^void VecR::operator-= (const double input) {$/;"	f	class:VecR
operator <	vecr.cpp	/^double VecR::operator< (const VecR& input) const {$/;"	f	class:VecR
operator =	matrixr.h	/^	void 	operator= (const MatR& input) {				\/\/ assignment$/;"	f	class:MatR
operator =	vecr.cpp	/^VecR& VecR::operator= (const VecR& input) {$/;"	f	class:VecR
operator ==	vecr.cpp	/^bool VecR::operator== (const VecR& input) const {$/;"	f	class:VecR
operator []	ambersystem.h	/^	Atom * operator[] (int index) { return _atoms[index]; }$/;"	f	class:AmberSystem
operator []	atom.cpp	/^double Atom::operator[] (const coord index) const {$/;"	f	class:Atom
operator []	crdfile.h	/^	VecR& operator[] (int index) { return _coords[index]; }$/;"	f	class:CRDFile
operator []	forcefile.h	/^	VecR& operator[] (int index) { return _forces[index]; }$/;"	f	class:ForceFile
operator []	histogram.h	/^	int		operator[] (int bin) { return _histogram[bin]; }$/;"	f	class:Histogram
operator []	histogram.h	/^	void	operator[] (double value) { _histogram[this->Bin(value)]++; }$/;"	f	class:Histogram
operator []	molecule.cpp	/^Atom * Molecule::operator[] (const string atomname) const {$/;"	f	class:Molecule
operator []	molecule.h	/^	Atom * operator[] (int index) const { return _atoms[index]; }	\/\/ retrieve an atom by array index$/;"	f	class:Molecule
operator []	pdbfile.h	/^	Molecule *operator[] (int index) { return _molecules[index]; }$/;"	f	class:PDBFile
operator []	vecr.cpp	/^double VecR::operator[] (const coord index) const {$/;"	f	class:VecR
operator []	vecr.cpp	/^double VecR::operator[] (const int index) const {$/;"	f	class:VecR
operator []	wannier.h	/^	VecR& operator[] (int index) { return _coords[index]; }$/;"	f	class:WannierFile
operator []	xyzfile.h	/^	Atom * operator[] (int index) { return _atoms[index]; }$/;"	f	class:XYZFile
operator []	xyzsystem.h	/^	Atom * operator[] (int index) {$/;"	f	class:XYZSystem
output	watersystem.h	/^	FILE * output;$/;"	m	class:WaterSystem
output	watersystem.h	/^	string output;$/;"	m	struct:WaterSystemParams
output_freq	watersystem.h	/^	int	output_freq;$/;"	m	class:WaterSystem
output_freq	watersystem.h	/^	int output_freq;$/;"	m	struct:WaterSystemParams
pbcflip	watersystem.h	/^	double	pbcflip;$/;"	m	class:WaterSystem
pbcflip	watersystem.h	/^	double pbcflip;$/;"	m	struct:WaterSystemParams
posbins	watersystem.h	/^	int		posbins;$/;"	m	class:WaterSystem
posmax	watersystem.h	/^	double	posmax;$/;"	m	class:WaterSystem
posmax	watersystem.h	/^	double posmin, posmax, posres;$/;"	m	struct:WaterSystemParams
posmin	watersystem.h	/^	double	posmin;$/;"	m	class:WaterSystem
posmin	watersystem.h	/^	double posmin, posmax, posres;$/;"	m	struct:WaterSystemParams
posres	watersystem.h	/^	double	posres;$/;"	m	class:WaterSystem
posres	watersystem.h	/^	double posmin, posmax, posres;$/;"	m	struct:WaterSystemParams
prmtop	watersystem.h	/^	string prmtop, mdcrd, mdvel;$/;"	m	struct:WaterSystemParams
q_pt	hno3analysis.cpp	/^double q_pt (XYZSystem& sys, Molecule * hno3) {$/;"	f
restart	watersystem.h	/^	int timesteps, restart;$/;"	m	struct:WaterSystemParams
restart	watersystem.h	/^	unsigned int timestep, restart;$/;"	m	class:WaterSystem
size	ambersystem.h	/^	int		size ()			const 	{ return _atoms.size(); }$/;"	f	class:AmberSystem
size	crdfile.h	/^	int size () 	const { return _size; }$/;"	f	class:CRDFile
size	forcefile.h	/^	int size () 	{ return _size; }$/;"	f	class:ForceFile
size	molecule.h	/^	int size () const				{ return _atoms.size(); }$/;"	f	class:Molecule
size	pdbfile.h	/^	int size () { return _numAtoms; }$/;"	f	class:PDBFile
size	wannier.h	/^	int size () 	const { return _size; }$/;"	f	class:WannierFile
size	xyzfile.h	/^	int size () const { return _atoms.size(); }$/;"	f	class:XYZFile
size	xyzsystem.h	/^	int size ()	const { return _atoms.size(); }$/;"	f	class:XYZSystem
sys	watersystem.h	/^	AmberSystem sys;$/;"	m	class:WaterSystem
timestep	watersystem.h	/^	unsigned int timestep, restart;$/;"	m	class:WaterSystem
timesteps	watersystem.h	/^	int timesteps, restart;$/;"	m	struct:WaterSystemParams
timesteps	watersystem.h	/^	unsigned int timesteps;$/;"	m	class:WaterSystem
trajectory	wateranalyzer.h	/^typedef vector<double> trajectory;$/;"	t
u	edge.h	/^	Node * u;$/;"	m	class:Edge
unbonded	bond.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded, covalent} bondtype;$/;"	e	enum:__anon4
unbonded	bondgraph.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded} bondtype;$/;"	e	enum:__anon2
unbonded	connectmatrix.h	/^typedef enum {ohbond, nobond, nhbond, hbond, unbonded} bondtype;$/;"	e	enum:__anon6
v	edge.h	/^	Node * v;$/;"	m	class:Edge
x	vecr.h	/^enum coord {x=0, y=1, z=2};$/;"	e	enum:coord
xx	matrixr.h	/^enum element {xx=0, yx=1, zx=2, xy=3, yy=4, zy=5, xz=6, yz=7, zz=8};$/;"	e	enum:element
xy	matrixr.h	/^enum element {xx=0, yx=1, zx=2, xy=3, yy=4, zy=5, xz=6, yz=7, zz=8};$/;"	e	enum:element
xz	matrixr.h	/^enum element {xx=0, yx=1, zx=2, xy=3, yy=4, zy=5, xz=6, yz=7, zz=8};$/;"	e	enum:element
y	vecr.h	/^enum coord {x=0, y=1, z=2};$/;"	e	enum:coord
yx	matrixr.h	/^enum element {xx=0, yx=1, zx=2, xy=3, yy=4, zy=5, xz=6, yz=7, zz=8};$/;"	e	enum:element
yy	matrixr.h	/^enum element {xx=0, yx=1, zx=2, xy=3, yy=4, zy=5, xz=6, yz=7, zz=8};$/;"	e	enum:element
yz	matrixr.h	/^enum element {xx=0, yx=1, zx=2, xy=3, yy=4, zy=5, xz=6, yz=7, zz=8};$/;"	e	enum:element
z	vecr.h	/^enum coord {x=0, y=1, z=2};$/;"	e	enum:coord
zx	matrixr.h	/^enum element {xx=0, yx=1, zx=2, xy=3, yy=4, zy=5, xz=6, yz=7, zz=8};$/;"	e	enum:element
zy	matrixr.h	/^enum element {xx=0, yx=1, zx=2, xy=3, yy=4, zy=5, xz=6, yz=7, zz=8};$/;"	e	enum:element
zz	matrixr.h	/^enum element {xx=0, yx=1, zx=2, xy=3, yy=4, zy=5, xz=6, yz=7, zz=8};$/;"	e	enum:element
~AdjacencyMatrix	adjacencymatrix.cpp	/^AdjacencyMatrix::~AdjacencyMatrix () {$/;"	f	class:AdjacencyMatrix
~AmberSystem	ambersystem.cpp	/^AmberSystem::~AmberSystem () {$/;"	f	class:AmberSystem
~Bond	bond.cpp	/^Bond::~Bond ()$/;"	f	class:Bond
~BoxFiller	boxfiller.cpp	/^BoxFiller::~BoxFiller() { };$/;"	f	class:BoxFiller
~CRDFile	crdfile.cpp	/^CRDFile::~CRDFile () {$/;"	f	class:CRDFile
~DipoleFieldTensor	dipolefieldtensor.cpp	/^DipoleFieldTensor::~DipoleFieldTensor () {$/;"	f	class:DipoleFieldTensor
~Edge	edge.cpp	/^Edge::~Edge () {$/;"	f	class:Edge
~ForceFile	forcefile.cpp	/^ForceFile::~ForceFile () {$/;"	f	class:ForceFile
~Graph	graph.cpp	/^Graph::~Graph () {$/;"	f	class:Graph
~Hydronium	h3o.cpp	/^Hydronium::~Hydronium () {$/;"	f	class:Hydronium
~Hydroxide	oh.cpp	/^Hydroxide::~Hydroxide () {$/;"	f	class:Hydroxide
~MPIMolSystem	ambermpisys.h	/^MPIMolSystem::~MPIMolSystem () {$/;"	f	class:MPIMolSystem
~MatR	matrixr.h	/^	~MatR () {};$/;"	f	class:MatR
~Molecule	molecule.cpp	/^Molecule::~Molecule () {$/;"	f	class:Molecule
~Nitrate	hno3.cpp	/^Nitrate::~Nitrate () {$/;"	f	class:Nitrate
~NitricAcid	hno3.cpp	/^NitricAcid::~NitricAcid () {$/;"	f	class:NitricAcid
~Node	node.cpp	/^Node::~Node () {$/;"	f	class:Node
~PDBFile	pdbfile.cpp	/^PDBFile::~PDBFile () {$/;"	f	class:PDBFile
~TOPFile	topfile.cpp	/^TOPFile::~TOPFile () {$/;"	f	class:TOPFile
~VecR	vecr.cpp	/^VecR::~VecR () {$/;"	f	class:VecR
~WannierFile	wannier.cpp	/^WannierFile::~WannierFile () {$/;"	f	class:WannierFile
~Water	h2o.cpp	/^Water::~Water () {$/;"	f	class:Water
~WaterSystem	watersystem.cpp	/^WaterSystem::~WaterSystem () {$/;"	f	class:WaterSystem
~XYZFile	xyzfile.cpp	/^XYZFile::~XYZFile () {$/;"	f	class:XYZFile
~XYZSystem	xyzsystem.cpp	/^XYZSystem::~XYZSystem () {$/;"	f	class:XYZSystem
